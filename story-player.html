<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ghost Logic - Odysiq</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600&family=Orbitron:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK v11.10.0 -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js';
        import { getFirestore, collection, doc, setDoc, getDoc, getDocs, query, where, connectFirestoreEmulator } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js';
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, updateProfile, connectAuthEmulator } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js';
        import { getAnalytics } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-analytics.js';
        
        // Your Firebase configuration (latest from Firebase Console)
        const firebaseConfig = {
            apiKey: "AIzaSyC_SVhI753WR_w-_75I1Zvfa7D5YvR4dIs",
            authDomain: "odysiq-90653.firebaseapp.com",
            projectId: "odysiq-90653",
            storageBucket: "odysiq-90653.firebasestorage.app",
            messagingSenderId: "249128085840",
            appId: "1:249128085840:web:6d75d2b17445997abf2455",
            measurementId: "G-DDR0NC2DC7"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const analytics = getAnalytics(app);
        
        // Add error handling for Firestore initialization
        try {
            // Test Firestore connection
            console.log('üî• Firebase initialized successfully');
            console.log('üìä Firestore instance:', db);
            console.log('üîê Auth instance:', auth);
        } catch (error) {
            console.error('‚ùå Firebase initialization error:', error);
        }
        
        // Make Firebase available globally with better error handling
        window.firebase = { 
            app,
            db, 
            auth, 
            getDoc, 
            setDoc, 
            doc, 
            collection, 
            query, 
            where, 
            getDocs, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            onAuthStateChanged, 
            signOut, 
            updateProfile 
        };
        
        // Enhanced error handler for Firestore operations
        window.firebaseErrorHandler = function(operation, error) {
            console.error(`‚ùå Firebase ${operation} error:`, error);
            if (error.code === 'permission-denied') {
                console.log('üîí Permission denied - check Firestore security rules');
                console.log('üí° Make sure you are authenticated and rules allow access');
            } else if (error.code === 'unauthenticated') {
                console.log('üö´ User not authenticated - please sign in');
            }
            return false;
        };
        
        console.log('‚úÖ Firebase v11.10.0 ready with enhanced error handling');
    </script>
    
    <!-- Stripe SDK -->
    <script src="https://js.stripe.com/v3/"></script>
    
    <!-- Configuration -->
    <script src="config.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* No page scrolling ever */
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0f 0%, #1a0e1a 25%, #0f1419 50%, #1a1a2e 75%, #16213e 100%);
            background-attachment: fixed;
            color: #fff;
            font-family: 'Fira Code', monospace;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100vw;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 20px;
            background: rgba(10, 10, 15, 0.92);
            backdrop-filter: blur(15px);
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            z-index: 99999;
            min-height: 90px;
            box-shadow: 
                0 3px 20px rgba(0, 0, 0, 0.8),
                0 0 30px rgba(255, 59, 59, 0.1),
                inset 0 -1px 0 rgba(0, 255, 255, 0.1);
            margin: 0;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 500;
            letter-spacing: 2px;
            color: #fff;
        }

        .story-logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            font-weight: 500;
            letter-spacing: 2px;
            color: #ff3b3b;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .control-buttons {
            display: flex;
            gap: 6px;
            align-items: center;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        .control-buttons:hover {
            opacity: 1;
        }

        .auth-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-profile {
            display: none;
            align-items: center;
            gap: 12px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            transition: all 0.3s ease;
            opacity: 0.8;
        }

        .user-profile:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            opacity: 1;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4dabf7, #339af0);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
        }

        .user-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .user-name {
            font-size: 12px;
            font-weight: 500;
            line-height: 1.2;
            color: rgba(255, 255, 255, 0.9);
        }

        .user-email {
            font-size: 10px;
            opacity: 0.6;
            line-height: 1.2;
        }

        .admin-badge {
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            color: #000;
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        .auth-buttons {
            display: flex;
            gap: 8px;
        }

        .auth-btn {
            padding: 8px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .auth-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .auth-btn.primary {
            background: linear-gradient(45deg, #4dabf7, #339af0);
            border-color: #4dabf7;
        }

        .auth-btn.primary:hover {
            background: linear-gradient(45deg, #339af0, #228be6);
            box-shadow: 0 4px 15px rgba(77, 171, 247, 0.3);
        }

        .sign-out-btn {
            background: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 4px 10px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 9px;
            transition: all 0.3s ease;
            font-family: 'Fira Code', monospace;
        }

        .sign-out-btn:hover {
            background: rgba(255, 107, 107, 0.1);
            border-color: #ff6b6b;
        }

        .back-button {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.5);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            transition: all 0.3s ease;
            text-decoration: none;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .control-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.5);
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 12px;
            transition: all 0.3s ease;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .control-btn.active {
            color: #ff3b3b;
            border-color: rgba(255, 59, 59, 0.2);
            background: rgba(255, 59, 59, 0.05);
        }

        .speed-control {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.5);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            transition: all 0.3s ease;
            min-width: 40px;
            height: 32px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .speed-control:hover {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .speed-control.active {
            color: #ff3b3b;
            border-color: rgba(255, 59, 59, 0.2);
            background: rgba(255, 59, 59, 0.05);
        }

        /* Main content area - middle section that fills remaining space */
        .story-container {
            flex: 1; /* Take remaining space between header and choices */
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            overflow-y: auto; /* Only this section scrolls */
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .story-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 500;
            margin-bottom: 10px;
            color: #ff3b3b;
            text-align: center;
            letter-spacing: 2px;
        }

        .story-subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 40px;
            font-size: 14px;
        }

        /* Scene content within the scrollable container */
        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 0;
            overflow: visible; /* Let content flow naturally */
        }

        /* Removed top fade gradient overlay - user didn't want the dark box at the top */

        /* Buffer zone between content and choices - removed static overlay that caused permanent fade line */

        .passage {
            background: transparent;
            border: none;
            padding: 0;
            margin-bottom: 15px;
            position: relative;
        }

        /* Line-by-line fading for crawler effect */
        .passage-text p {
            margin: 8px 0;
            line-height: 1.6;
            transition: opacity 0.5s ease-out;
        }

        /* Gradient fade classes for different line positions */
        .line-fade-3 { opacity: 0; }      /* 3+ lines back - invisible */
        .line-fade-2 { opacity: 0.25; }   /* 2 lines back - 25% visible */
        .line-fade-1 { opacity: 0.5; }    /* 1 line back - 50% visible */
        .line-current { opacity: 1; }     /* Current line - fully visible */

        .passage-text {
            font-size: 16px;
            line-height: 1.8;
            margin-bottom: 20px;
            white-space: pre-wrap;
            min-height: auto;
        }

        /* Show all mode - content flows from top */
        .story-container.show-all .content-area {
            justify-content: flex-start; /* Align content to top when scrolling */
        }

        /* No longer needed - top fade gradient overlay removed entirely */

        /* In crawler mode, position content at bottom of scene window */
        .content-area:not(.show-all-content) {
            justify-content: flex-end; /* Align content to bottom for crawler effect */
        }
        
        /* Remove any extra margins in crawler mode */
        .story-container:not(.show-all) {
            overflow: hidden; /* Hide any overflow in crawler mode */
        }

        .story-container.show-all .passage-text p {
            opacity: 1 !important; /* Override all fade classes */
            transform: translateY(0) !important; /* Reset any transforms */
        }
        
        /* Ensure fade classes are properly reset when not in crawler mode */
        .story-container.show-all .passage-text p.line-fade-3,
        .story-container.show-all .passage-text p.line-fade-2,
        .story-container.show-all .passage-text p.line-fade-1,
        .story-container.show-all .passage-text p.line-current {
            opacity: 1 !important;
            transform: translateY(0) !important;
        }



        .typing-cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background: #ff3b3b;
            animation: blink 1s infinite;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .choices.hidden {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .choices.visible {
            opacity: 1;
            pointer-events: all;
            transition: opacity 0.3s ease;
        }



        /* Scene Transition Effects */
        .scene-transition {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .scene-transition.active {
            opacity: 1;
            pointer-events: all;
        }

        .scene-transition.glitch {
            background: 
                linear-gradient(45deg, rgba(10, 10, 15, 0.9) 25%, #ff3b3b 25%, #ff3b3b 50%, rgba(10, 10, 15, 0.9) 50%, rgba(10, 10, 15, 0.9) 75%, #00ffff 75%),
                radial-gradient(ellipse at center, rgba(255, 59, 59, 0.3) 0%, transparent 70%),
                radial-gradient(ellipse at 30% 70%, rgba(0, 255, 255, 0.2) 0%, transparent 50%);
            background-size: 4px 4px, 100% 100%, 100% 100%;
            animation: cyberpunkGlitchTransition 0.5s ease-in-out;
            backdrop-filter: blur(2px);
        }

        /* Paywall Styles */
        .paywall-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(10, 10, 15, 0.98) 0%, rgba(26, 14, 26, 0.98) 50%, rgba(15, 20, 25, 0.98) 100%);
            backdrop-filter: blur(15px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .paywall-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

                 .paywall-container {
             max-width: 450px;
             background: linear-gradient(145deg, rgba(5, 5, 10, 0.98) 0%, rgba(15, 8, 15, 0.98) 100%);
             border: 2px solid rgba(0, 255, 255, 0.6);
             border-radius: 8px;
             padding: 25px;
             text-align: center;
             box-shadow: 
                 0 25px 80px rgba(0, 0, 0, 0.9),
                 0 0 60px rgba(0, 255, 255, 0.2),
                 inset 0 1px 0 rgba(255, 255, 255, 0.15),
                 inset 0 0 20px rgba(0, 255, 255, 0.05);
             position: relative;
             overflow: hidden;
             backdrop-filter: blur(20px);
         }

        .paywall-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            animation: paywallScan 3s infinite;
        }

        @keyframes paywallScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

                 .paywall-title {
             font-family: 'Orbitron', sans-serif;
             font-size: 22px;
             font-weight: 600;
             color: #00ffff;
             margin-bottom: 12px;
             text-shadow: 
                 0 0 5px rgba(0, 255, 255, 0.4),
                 0 0 10px rgba(0, 255, 255, 0.2);
             letter-spacing: 1px;
             text-transform: uppercase;
         }

                 .paywall-subtitle {
             font-size: 15px;
             color: rgba(255, 255, 255, 0.9);
             margin-bottom: 16px;
             line-height: 1.4;
             font-weight: 400;
             text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
         }

                 .paywall-features {
             text-align: left;
             margin: 16px 0;
             padding: 16px;
             background: rgba(0, 0, 0, 0.5);
             border: 1px solid rgba(0, 255, 255, 0.4);
             border-radius: 6px;
             box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.1);
         }

                 .paywall-features h3 {
             color: #ff3b3b;
             font-family: 'Orbitron', sans-serif;
             font-size: 15px;
             margin-bottom: 10px;
             text-align: center;
         }

        .paywall-features ul {
            list-style: none;
            padding: 0;
        }

                 .paywall-features li {
             padding: 4px 0;
             color: rgba(255, 255, 255, 0.95);
             font-size: 13px;
             font-weight: 400;
             position: relative;
             padding-left: 18px;
             text-shadow: 0 1px 1px rgba(0, 0, 0, 0.6);
         }

        .paywall-features li::before {
            content: '‚ñ∂';
            position: absolute;
            left: 0;
            color: #00ffff;
            font-size: 12px;
        }

                 .paywall-buttons {
             display: flex;
             flex-direction: column;
             gap: 10px;
             margin-top: 16px;
         }

                 .paywall-btn {
             padding: 10px 20px;
             border: 2px solid;
             border-radius: 5px;
             background: transparent;
             color: #fff;
             font-family: 'Fira Code', monospace;
             font-size: 13px;
             font-weight: 500;
             cursor: pointer;
             transition: all 0.3s ease;
             text-decoration: none;
             display: inline-block;
             position: relative;
             overflow: hidden;
         }

        .paywall-btn.primary {
            border-color: #00ffff;
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.1), rgba(0, 255, 255, 0.2));
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .paywall-btn.primary:hover {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.3));
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .paywall-btn.secondary {
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.8);
        }

                 .paywall-btn.secondary:hover {
             border-color: rgba(255, 255, 255, 0.5);
             background: rgba(255, 255, 255, 0.1);
             color: #fff;
         }

         .paywall-btn.promo {
             border-color: #ff3b3b;
             background: linear-gradient(45deg, rgba(255, 59, 59, 0.1), rgba(255, 59, 59, 0.2));
             color: #ff3b3b;
             text-shadow: 0 0 10px rgba(255, 59, 59, 0.5);
             padding: 12px 20px;
             font-size: 14px;
         }

         .paywall-btn.promo:hover {
             background: linear-gradient(45deg, rgba(255, 59, 59, 0.2), rgba(255, 59, 59, 0.3));
             box-shadow: 0 0 20px rgba(255, 59, 59, 0.4);
             transform: translateY(-1px);
         }

         .promo-section {
             margin-top: 14px;
             padding-top: 12px;
             border-top: 1px solid rgba(0, 255, 255, 0.2);
         }

         .promo-toggle {
             cursor: pointer;
             color: rgba(255, 255, 255, 0.7);
             font-size: 13px;
             padding: 8px;
             border-radius: 4px;
             transition: all 0.3s ease;
             text-align: center;
         }

         .promo-toggle:hover {
             color: #00ffff;
             background: rgba(0, 255, 255, 0.1);
         }

         .promo-input-container {
             margin-top: 10px;
             display: flex;
             gap: 8px;
             align-items: center;
         }

         .promo-input {
             flex: 1;
             padding: 10px 12px;
             background: rgba(0, 0, 0, 0.6);
             border: 2px solid rgba(0, 255, 255, 0.3);
             border-radius: 5px;
             color: #fff;
             font-family: 'Fira Code', monospace;
             font-size: 13px;
             text-transform: uppercase;
             letter-spacing: 1px;
         }

         .promo-input:focus {
             outline: none;
             border-color: rgba(0, 255, 255, 0.6);
             box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
         }

         .promo-input::placeholder {
             color: rgba(255, 255, 255, 0.4);
             text-transform: none;
             letter-spacing: normal;
         }

         .promo-result {
             margin-top: 10px;
             padding: 10px;
             border-radius: 5px;
             font-size: 13px;
             font-weight: 500;
             text-align: center;
         }

         .promo-result.success {
             background: rgba(0, 255, 0, 0.1);
             border: 1px solid rgba(0, 255, 0, 0.3);
             color: #00ff00;
         }

         .promo-result.error {
             background: rgba(255, 59, 59, 0.1);
             border: 1px solid rgba(255, 59, 59, 0.3);
             color: #ff3b3b;
         }

         .promo-result.info {
             background: rgba(0, 255, 255, 0.1);
             border: 1px solid rgba(0, 255, 255, 0.3);
             color: #00ffff;
         }

        .paywall-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 24px;
            cursor: pointer;
            transition: color 0.3s ease;
            z-index: 1;
        }

        .paywall-close:hover {
            color: #ff3b3b;
        }

        .auth-prompt {
            background: rgba(255, 59, 59, 0.1);
            border: 1px solid rgba(255, 59, 59, 0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .auth-prompt h3 {
            color: #ff3b3b;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .auth-prompt p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-bottom: 15px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #00ffff;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes cyberpunkGlitchTransition {
            0% { 
                opacity: 0; 
                background-position: 0 0, 0 0, 0 0; 
                filter: hue-rotate(0deg);
            }
            25% { 
                opacity: 0.8; 
                background-position: 2px 0, -10px 10px, 5px -5px; 
                filter: hue-rotate(90deg);
            }
            50% { 
                opacity: 1; 
                background-position: -2px 2px, 10px -10px, -5px 5px; 
                filter: hue-rotate(180deg);
            }
            75% { 
                opacity: 0.8; 
                background-position: 2px -2px, -5px 15px, 8px -8px; 
                filter: hue-rotate(270deg);
            }
            100% { 
                opacity: 0; 
                background-position: 0 0, 0 0, 0 0; 
                filter: hue-rotate(360deg);
            }
        }

        /* Choice Animation Enhancements */
        .choice-button {
            background: rgba(255, 59, 59, 0.1);
            border: 1px solid rgba(255, 59, 59, 0.3);
            color: #fff;
            padding: 12px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 13px;
            line-height: 1.4;
            transition: all 0.3s ease;
            text-align: left;
            position: relative;
            overflow: hidden;
            transform: translateY(20px);
            opacity: 0;
            min-height: 44px; /* Minimum touch target size */
            display: flex;
            align-items: center;
            white-space: normal; /* Allow text wrapping */
            word-wrap: break-word;
            hyphens: auto;
        }

        .choice-button.reveal {
            transform: translateY(0);
            opacity: 1;
        }

        .choice-button:before {
            content: '>';
            position: absolute;
            left: -20px;
            opacity: 0;
            transition: all 0.3s ease;
            color: #ff3b3b;
        }

        .choice-button:hover {
            background: rgba(255, 59, 59, 0.2);
            border-color: rgba(255, 59, 59, 0.8);
            padding-left: 32px;
            transform: translateX(3px);
            box-shadow: 0 0 15px rgba(255, 59, 59, 0.3);
        }

        .choice-button:hover:before {
            opacity: 1;
            left: 15px;
        }

        /* Neon pulse effect for active choices */
        .choice-button:hover {
            animation: neonPulse 1.5s ease-in-out infinite alternate;
        }

        @keyframes neonPulse {
            0% { box-shadow: 0 0 15px rgba(255, 59, 59, 0.3); }
            100% { box-shadow: 0 0 25px rgba(255, 59, 59, 0.6), 0 0 35px rgba(255, 59, 59, 0.3); }
        }



        .passage-text p {
            margin-bottom: 15px;
        }

        /* Enhanced Cyberpunk Background */
        body:before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                /* Grid pattern */
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(0deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                /* Diagonal circuit lines */
                linear-gradient(45deg, transparent 48%, rgba(255, 59, 59, 0.08) 49%, rgba(255, 59, 59, 0.08) 51%, transparent 52%),
                /* Scanlines */
                linear-gradient(90deg, transparent 98%, rgba(0, 255, 255, 0.04) 100%),
                linear-gradient(0deg, transparent 98%, rgba(255, 59, 59, 0.03) 100%);
            background-size: 
                40px 40px,
                40px 40px,
                200px 200px,
                3px 3px,
                4px 4px;
            animation: cyberpunkScan 25s linear infinite;
            pointer-events: none;
            z-index: 1;
            opacity: 0.6;
        }

        body:after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                /* Radial glow effects */
                radial-gradient(ellipse at 20% 30%, rgba(255, 59, 59, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 70%, rgba(0, 255, 255, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 100%, rgba(147, 51, 234, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
            animation: glowPulse 30s ease-in-out infinite;
        }

        @keyframes cyberpunkScan {
            0% { 
                transform: translateY(0) rotate(0deg); 
                opacity: 0.6; 
            }
            50% { 
                opacity: 0.8; 
            }
            100% { 
                transform: translateY(20px) rotate(0.1deg); 
                opacity: 0.6; 
            }
        }

        @keyframes glowPulse {
            0%, 100% { 
                opacity: 1; 
                filter: blur(0px); 
            }
            50% { 
                opacity: 0.7; 
                filter: blur(1px); 
            }
        }

        /* Ensure content is above background */
        .header, .story-container, .scene-transition, .state-info {
            position: relative;
            z-index: 2;
        }

        /* Dialogue Styling */
        .dialogue {
            position: relative;
            margin: 15px 0;
            padding: 12px 15px;
            border-left: 3px solid;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 0 4px 4px 0;
        }

        .dialogue.protagonist {
            border-left-color: #4da6ff;
            color: #b3d9ff;
        }

        .dialogue.ai {
            border-left-color: #00ffff;
            color: #b3ffff;
        }

        .dialogue.villain {
            border-left-color: #ff3b9a;
            color: #ffb3d1;
        }

        .dialogue.other {
            border-left-color: #888;
            color: #ccc;
        }

        /* Auto-scroll indicator */
        .scroll-indicator {
            position: fixed;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 100px;
            background: rgba(255, 59, 59, 0.1);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .scroll-indicator.active {
            opacity: 1;
        }

        .scroll-indicator:after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: #ff3b3b;
            border-radius: 2px;
            animation: scrollProgress 2s ease-in-out infinite;
        }

        @keyframes scrollProgress {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(200%); }
        }

        /* Link Window - fixed bottom section */
        .choices {
            min-height: 120px; /* Minimum height */
            max-height: 160px; /* Maximum height before scrolling */
            flex-shrink: 0; /* Never shrink */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 8px;
            background: linear-gradient(to bottom, 
                transparent 0%, 
                rgba(10, 10, 15, 0.4) 10%,
                rgba(10, 10, 15, 0.7) 30%, 
                rgba(10, 10, 15, 0.9) 50%, 
                rgba(10, 10, 15, 0.95) 100%
            );
            backdrop-filter: blur(8px);
            border-top: 1px solid rgba(0, 255, 255, 0.1);
            padding: 12px 20px 16px 20px;
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling if content exceeds max-height */
            box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.5);
        }

        /* Rating and Review System - Modal Styles */
        .review-modal-content {
            padding: 0;
        }

        .star-rating {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .star {
            font-size: 28px;
            color: rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: 0 0 5px currentColor;
            user-select: none;
        }

        .star:hover,
        .star.active {
            color: #ff3b3b;
            text-shadow: 0 0 15px rgba(255, 59, 59, 0.8);
            transform: scale(1.1);
        }

        .star.selected {
            color: #ff3b3b;
            text-shadow: 0 0 15px rgba(255, 59, 59, 0.8);
            transform: scale(1.1);
            animation: starPulse 0.3s ease;
        }

        @keyframes starPulse {
            0% { transform: scale(1.1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.1); }
        }

        .review-textarea {
            width: 100%;
            min-height: 80px;
            background: rgba(10, 10, 15, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            padding: 12px;
            color: #fff;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            resize: vertical;
            outline: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .review-textarea:focus {
            border-color: rgba(255, 59, 59, 0.5);
            box-shadow: 
                0 0 15px rgba(255, 59, 59, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .review-textarea::placeholder {
            color: rgba(255, 255, 255, 0.4);
            font-style: italic;
        }

        .review-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .review-button {
            padding: 10px 20px;
            background: linear-gradient(135deg, 
                rgba(255, 59, 59, 0.2) 0%, 
                rgba(255, 59, 59, 0.1) 100%
            );
            border: 1px solid rgba(255, 59, 59, 0.4);
            border-radius: 4px;
            color: #ff3b3b;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            outline: none;
        }

        .review-button:hover {
            background: linear-gradient(135deg, 
                rgba(255, 59, 59, 0.3) 0%, 
                rgba(255, 59, 59, 0.2) 100%
            );
            border-color: rgba(255, 59, 59, 0.6);
            box-shadow: 0 0 15px rgba(255, 59, 59, 0.4);
            transform: translateY(-1px);
        }

        .review-button:active {
            transform: translateY(0);
        }

        .review-button.secondary {
            background: linear-gradient(135deg, 
                rgba(0, 255, 255, 0.1) 0%, 
                rgba(0, 255, 255, 0.05) 100%
            );
            border-color: rgba(0, 255, 255, 0.3);
            color: #00ffff;
        }

        .review-button.secondary:hover {
            background: linear-gradient(135deg, 
                rgba(0, 255, 255, 0.2) 0%, 
                rgba(0, 255, 255, 0.1) 100%
            );
            border-color: rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .review-success {
            text-align: center;
            color: #00ffff;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            padding: 16px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            margin-bottom: 12px;
        }

        /* Loading states and progress indicators */
        .loading {
            text-align: center;
            padding: 100px 20px;
            color: #888;
            position: relative;
        }

        .loading:after {
            content: '';
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #ff3b3b;
            border-radius: 2px;
            animation: loadingProgress 2s ease-in-out infinite;
        }

        @keyframes loadingProgress {
            0% { width: 10px; opacity: 0.3; }
            50% { width: 60px; opacity: 1; }
            100% { width: 10px; opacity: 0.3; }
        }

        /* Choice button loading state */
        .choice-button.loading {
            position: relative;
            pointer-events: none;
            color: transparent;
        }

        .choice-button.loading:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid #ff3b3b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Progress bar for story completion - always visible */
        .progress-bar {
            position: fixed;
            top: 110px; /* Below single header */
            left: 20px;
            right: 20px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 1px;
            overflow: hidden;
            opacity: 1;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .progress-bar:after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #ff3b3b, #00ffff);
            border-radius: 1px;
            transition: width 0.5s ease;
            width: var(--progress, 0%);
        }

        .error {
            text-align: center;
            padding: 100px 20px;
            color: #ff6b6b;
        }

        .state-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 10px;
            font-size: 11px;
            color: #888;
            max-width: 200px;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 40px;
            width: 90%;
            max-width: 450px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.show .modal {
            transform: translateY(0);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(45deg, #4dabf7, #339af0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .modal-subtitle {
            font-size: 14px;
            opacity: 0.7;
            line-height: 1.4;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 500;
            color: #e9ecef;
        }

        .form-input {
            width: 100%;
            padding: 14px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #4dabf7;
            box-shadow: 0 0 0 3px rgba(77, 171, 247, 0.1);
            background: rgba(255, 255, 255, 0.08);
        }

        .form-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 25px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .checkbox-input {
            width: 18px;
            height: 18px;
            accent-color: #4dabf7;
        }

        .checkbox-label {
            font-size: 12px;
            color: #e9ecef;
            line-height: 1.4;
        }

        .form-buttons {
            display: flex;
            gap: 12px;
            margin-top: 25px;
        }

        .form-button {
            flex: 1;
            padding: 14px 20px;
            border-radius: 8px;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            position: relative;
            overflow: hidden;
        }

        .form-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .form-button.secondary {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .form-button.secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .form-button.primary {
            background: linear-gradient(45deg, #4dabf7, #339af0);
            color: #fff;
            border: 1px solid #4dabf7;
        }

        .form-button.primary:hover:not(:disabled) {
            background: linear-gradient(45deg, #339af0, #228be6);
            box-shadow: 0 4px 15px rgba(77, 171, 247, 0.3);
            transform: translateY(-1px);
        }

        .loading-spinner {
            display: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .form-button.loading .loading-spinner {
            display: inline-block;
        }

        .message {
            margin-top: 15px;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.4;
            text-align: center;
        }

        .message.error {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            color: #ff8787;
        }

        .message.success {
            background: rgba(81, 207, 102, 0.1);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #8ce99a;
        }

        .auth-toggle {
            text-align: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .auth-toggle a {
            color: #4dabf7;
            text-decoration: none;
            font-size: 13px;
            transition: color 0.3s ease;
        }

        .auth-toggle a:hover {
            color: #339af0;
        }

        /* Admin Panel Styles */
        .admin-panel {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 320px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(255, 59, 59, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            z-index: 10000;
            font-family: 'Fira Code', monospace;
            font-size: 12px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(255, 59, 59, 0.2);
        }

        .admin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(255, 59, 59, 0.1);
            border-bottom: 1px solid rgba(255, 59, 59, 0.2);
            border-radius: 6px 6px 0 0;
        }

        .admin-title {
            color: #ff3b3b;
            font-weight: 500;
            font-size: 14px;
        }

        .admin-toggle {
            background: none;
            border: 1px solid rgba(255, 59, 59, 0.3);
            color: #ff3b3b;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .admin-toggle:hover {
            background: rgba(255, 59, 59, 0.2);
            border-color: #ff3b3b;
        }

        .admin-content {
            padding: 15px;
        }

        .admin-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .admin-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .admin-section label {
            display: block;
            color: #fff;
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .admin-section select {
            width: 70%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 6px 8px;
            border-radius: 3px;
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            margin-right: 8px;
        }

        .admin-section select option {
            background: #000;
            color: #fff;
        }

        .admin-btn {
            background: rgba(255, 59, 59, 0.1);
            border: 1px solid rgba(255, 59, 59, 0.3);
            color: #ff3b3b;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .admin-btn:hover {
            background: rgba(255, 59, 59, 0.2);
            border-color: #ff3b3b;
        }

        .admin-btn.small {
            padding: 4px 8px;
            font-size: 10px;
            margin-right: 6px;
        }

        .game-vars {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            padding: 8px;
            margin-bottom: 8px;
            min-height: 60px;
            max-height: 120px;
            overflow-y: auto;
        }

        .game-var {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .game-var:last-child {
            border-bottom: none;
        }

        .var-name {
            color: #00ffff;
            font-weight: 500;
        }

        .var-value {
            color: #ffd43b;
            font-style: italic;
        }

        .var-delete {
            background: none;
            border: none;
            color: #ff6b6b;
            cursor: pointer;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 2px;
            transition: background 0.3s ease;
        }

        .var-delete:hover {
            background: rgba(255, 107, 107, 0.2);
        }

        .no-vars {
            color: #888;
            font-style: italic;
            text-align: center;
            padding: 10px;
        }

        .current-scene-info {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            padding: 8px;
            font-size: 11px;
        }

        .current-scene-info div {
            margin-bottom: 4px;
        }

        .current-scene-info div:last-child {
            margin-bottom: 0;
        }

        .current-scene-info span {
            color: #00ffff;
            font-weight: 500;
        }

        /* Admin button in header */
        .admin-access-btn {
            background: rgba(255, 59, 59, 0.1);
            border: 1px solid rgba(255, 59, 59, 0.3);
            color: #ff3b3b;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            transition: all 0.3s ease;
            height: 32px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .admin-access-btn:hover {
            background: rgba(255, 59, 59, 0.2);
            border-color: #ff3b3b;
        }

        .glitch-text {
            position: relative;
            color: #ff3b3b;
            font-weight: 500;
        }

        .glitch-text.glitch-active:before,
        .glitch-text.glitch-active:after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .glitch-text.glitch-active:before {
            animation: glitch-anim-1 0.5s linear;
            color: #ff0000;
            z-index: -1;
        }

        .glitch-text.glitch-active:after {
            animation: glitch-anim-2 0.5s linear;
            color: #00ffff;
            z-index: -2;
        }

        @keyframes glitch-anim-1 {
            0% { clip: rect(44px, 9999px, 56px, 0); transform: translateX(0); }
            10% { clip: rect(44px, 9999px, 56px, 0); transform: translateX(-2px); }
            20% { clip: rect(98px, 9999px, 44px, 0); transform: translateX(2px); }
            30% { clip: rect(98px, 9999px, 44px, 0); transform: translateX(-1px); }
            40% { clip: rect(85px, 9999px, 98px, 0); transform: translateX(1px); }
            50% { clip: rect(85px, 9999px, 98px, 0); transform: translateX(-2px); }
            60% { clip: rect(44px, 9999px, 56px, 0); transform: translateX(2px); }
            70% { clip: rect(44px, 9999px, 56px, 0); transform: translateX(-1px); }
            80% { clip: rect(98px, 9999px, 44px, 0); transform: translateX(1px); }
            90% { clip: rect(98px, 9999px, 44px, 0); transform: translateX(-2px); }
            100% { clip: rect(85px, 9999px, 98px, 0); transform: translateX(0); }
        }

        @keyframes glitch-anim-2 {
            0% { clip: rect(65px, 9999px, 119px, 0); transform: translateX(0); }
            15% { clip: rect(65px, 9999px, 119px, 0); transform: translateX(2px); }
            25% { clip: rect(46px, 9999px, 12px, 0); transform: translateX(-1px); }
            35% { clip: rect(46px, 9999px, 12px, 0); transform: translateX(1px); }
            45% { clip: rect(77px, 9999px, 108px, 0); transform: translateX(-2px); }
            55% { clip: rect(77px, 9999px, 108px, 0); transform: translateX(1px); }
            65% { clip: rect(65px, 9999px, 119px, 0); transform: translateX(-1px); }
            75% { clip: rect(65px, 9999px, 119px, 0); transform: translateX(2px); }
            85% { clip: rect(46px, 9999px, 12px, 0); transform: translateX(-1px); }
            95% { clip: rect(46px, 9999px, 12px, 0); transform: translateX(1px); }
            100% { clip: rect(77px, 9999px, 108px, 0); transform: translateX(0); }
        }

        /* Show All button */
        .show-all-btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.5);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            transition: all 0.3s ease;
            min-width: 60px;
            height: 32px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .show-all-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .show-all-btn.active {
            color: #ff3b3b;
            border-color: rgba(255, 59, 59, 0.2);
            background: rgba(255, 59, 59, 0.05);
        }

        /* Special text formatting effects */
        .neon-highlight {
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 15px #00ffff;
            font-weight: 500;
            animation: neonGlow 2s ease-in-out infinite alternate;
        }

        @keyframes neonGlow {
            0% { text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 15px #00ffff; }
            100% { text-shadow: 0 0 8px #00ffff, 0 0 16px #00ffff, 0 0 24px #00ffff; }
        }

        .interactive-term {
            color: #ffd43b;
            border-bottom: 1px dotted rgba(255, 212, 59, 0.5);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .interactive-term:hover {
            color: #fff;
            text-shadow: 0 0 8px #ffd43b;
            border-bottom-color: #ffd43b;
            transform: translateY(-1px);
        }

        .discovery-text {
            color: #ff3b3b;
            font-weight: 500;
            background: rgba(255, 59, 59, 0.1);
            padding: 2px 4px;
            border-radius: 2px;
            border-left: 2px solid #ff3b3b;
        }

        /* Time jump formatting */
        .time-jump {
            display: block;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 500;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin: 30px 0;
            padding: 15px 20px;
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 4px;
            position: relative;
            animation: timeJumpDramaticPulse 2.5s ease-in-out infinite alternate;
        }

        .time-jump:before,
        .time-jump:after {
            content: '‚óÜ';
            color: #00ffff;
            font-size: 12px;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            animation: timeJumpDiamondPulse 2.5s ease-in-out infinite alternate;
        }

        .time-jump:before {
            left: 10px;
        }

        .time-jump:after {
            right: 10px;
        }

        @keyframes timeJumpDramaticPulse {
            0% { 
                text-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.15);
                border-color: rgba(0, 255, 255, 0.2);
                background: rgba(0, 255, 255, 0.05);
            }
            50% {
                text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
                box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
                border-color: rgba(0, 255, 255, 0.6);
                background: rgba(0, 255, 255, 0.1);
            }
            100% { 
                text-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
                box-shadow: 0 0 50px rgba(0, 255, 255, 0.4);
                border-color: rgba(0, 255, 255, 0.8);
                background: rgba(0, 255, 255, 0.12);
            }
        }

        @keyframes timeJumpDiamondPulse {
            0% { 
                opacity: 0.6;
                text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
            }
            50% {
                opacity: 0.9;
                text-shadow: 0 0 12px rgba(0, 255, 255, 0.7);
            }
            100% { 
                opacity: 1;
                text-shadow: 0 0 15px rgba(0, 255, 255, 1);
            }
        }

        /* Computer console message */
        .console-message {
            font-family: 'Fira Code', monospace;
            background: rgba(0, 100, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-left: 4px solid #00ff00;
            color: #00ff88;
            padding: 12px 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
            position: relative;
            font-size: 14px;
            line-height: 1.4;
        }

        .console-message:before {
            content: '> ';
            color: #00ff00;
            font-weight: bold;
        }

        .console-message.blinking:after {
            content: '‚ñà';
            color: #00ff00;
            animation: blink 1s infinite;
            margin-left: 2px;
        }

        /* Multi-line console block */
        .console-block {
            font-family: 'Fira Code', monospace;
            background: rgba(0, 100, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-left: 4px solid #00ff00;
            color: #00ff88;
            padding: 15px 18px;
            margin: 15px 0;
            border-radius: 0 6px 6px 0;
            position: relative;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.1);
        }

        .console-line {
            margin: 3px 0;
            white-space: pre-wrap;
        }

        .console-line.prompt {
            color: #00ff00;
            font-weight: 500;
        }

        /* Console block header effect */
        .console-block:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, #00ff00, transparent);
            opacity: 0.6;
        }

        /* Warning console message */
        .console-warning {
            font-family: 'Fira Code', monospace;
            background: rgba(255, 100, 0, 0.1);
            border: 1px solid rgba(255, 165, 0, 0.4);
            border-left: 4px solid #ff6600;
            color: #ffaa00;
            padding: 12px 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
            position: relative;
            font-size: 14px;
            line-height: 1.4;
            animation: warningPulse 2s ease-in-out infinite alternate;
        }

        .console-warning:before {
            content: '‚ö† WARNING: ';
            color: #ff6600;
            font-weight: bold;
        }

        @keyframes warningPulse {
            0% { 
                background: rgba(255, 100, 0, 0.1);
                border-color: rgba(255, 165, 0, 0.4);
            }
            100% { 
                background: rgba(255, 100, 0, 0.2);
                border-color: rgba(255, 165, 0, 0.6);
            }
        }

        /* AI voice speaking */
        .ai-voice {
            font-family: 'Fira Code', monospace;
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-left: 4px solid #00ffff;
            color: #88ddff;
            padding: 15px 18px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            position: relative;
            font-size: 15px;
            line-height: 1.5;
            font-style: italic;
        }

        .ai-voice:before {
            content: '';
            color: #00ffff;
            font-weight: bold;
            font-style: normal;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ai-voice.processing:after {
            content: ' ...';
            color: #00ffff;
            animation: aiProcessing 1.5s ease-in-out infinite;
        }

        @keyframes aiProcessing {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }



        /* Text message formatting */
        .text-message {
            font-family: 'Fira Code', monospace;
            background: rgba(64, 224, 208, 0.08);
            border: 1px solid rgba(64, 224, 208, 0.25);
            border-left: 3px solid #40e0d0;
            color: #b8f5f0;
            padding: 10px 14px;
            margin: 12px 0;
            border-radius: 8px;
            position: relative;
            font-size: 14px;
            line-height: 1.4;
            box-shadow: 0 2px 8px rgba(64, 224, 208, 0.15);
            backdrop-filter: blur(2px);
        }

        /* Log entry formatting */
        .log-entry {
            font-family: 'Fira Code', monospace;
            background: rgba(255, 165, 0, 0.08);
            border: 1px solid rgba(255, 165, 0, 0.25);
            border-left: 4px solid #ffa500;
            color: #ffd580;
            padding: 12px 16px;
            margin: 15px 0;
            border-radius: 6px;
            position: relative;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 2px 10px rgba(255, 165, 0, 0.15);
            backdrop-filter: blur(2px);
        }

        .log-entry .log-header {
            color: #ffb84d;
            font-weight: 600;
            text-shadow: 0 0 5px rgba(255, 184, 77, 0.3);
        }

        .log-entry .log-emphasis {
            color: #ffcc80;
            font-style: italic;
            opacity: 0.9;
        }

        /* HELIX system message formatting */
        .helix-message {
            font-family: 'Fira Code', monospace;
            background: rgba(255, 0, 100, 0.12);
            border: 1px solid rgba(255, 0, 100, 0.3);
            border-left: 4px solid #ff0064;
            color: #ff99cc;
            padding: 12px 16px;
            margin: 15px 0;
            border-radius: 8px;
            position: relative;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 2px 12px rgba(255, 0, 100, 0.2);
            backdrop-filter: blur(2px);
            animation: helix-pulse 3s ease-in-out infinite;
        }

        .helix-message::before {
            content: "‚ó¶ HELIX SYSTEM ‚ó¶";
            position: absolute;
            top: -8px;
            left: 12px;
            background: rgba(0, 0, 0, 0.9);
            color: #ff0064;
            padding: 2px 8px;
            font-size: 10px;
            font-weight: 600;
            border-radius: 3px;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(255, 0, 100, 0.5);
        }

        .helix-message .helix-header {
            color: #ff4d94;
            font-weight: 600;
            text-shadow: 0 0 5px rgba(255, 77, 148, 0.4);
        }

        .helix-message .helix-emphasis {
            color: #ffb3d9;
            font-style: italic;
            opacity: 0.95;
        }

        @keyframes helix-pulse {
            0%, 100% {
                box-shadow: 0 2px 12px rgba(255, 0, 100, 0.2);
                border-color: rgba(255, 0, 100, 0.3);
            }
            50% {
                box-shadow: 0 2px 15px rgba(255, 0, 100, 0.35);
                border-color: rgba(255, 0, 100, 0.5);
            }
        }

        /* SYSTEM message formatting - cold, bureaucratic with blinking */
        .system-message {
            font-family: 'Fira Code', monospace;
            background: rgba(128, 128, 128, 0.08);
            border: 1px solid rgba(128, 128, 128, 0.25);
            border-left: 4px solid #808080;
            color: #b8b8b8;
            padding: 12px 16px;
            margin: 15px 0;
            border-radius: 4px;
            position: relative;
            font-size: 13px;
            line-height: 1.4;
            box-shadow: 0 2px 8px rgba(128, 128, 128, 0.1);
            backdrop-filter: blur(2px);
            letter-spacing: 0.5px;
            text-transform: uppercase;
            animation: system-blink 2s ease-in-out infinite;
        }

        .system-message .system-header {
            color: #999999;
            font-weight: 600;
            text-shadow: 0 0 3px rgba(153, 153, 153, 0.3);
        }

        .system-message .system-emphasis {
            color: #cccccc;
            font-style: italic;
            opacity: 0.9;
        }

        @keyframes system-blink {
            0%, 50% {
                opacity: 1;
            }
            75% {
                opacity: 0.3;
            }
            100% {
                opacity: 1;
            }
        }

        /* Purge flash effect - dramatic screen flash */
        .purge-flash {
            font-family: 'Fira Code', monospace;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.8);
            color: #ffffff;
            padding: 20px 25px;
            margin: 25px 0;
            border-radius: 0;
            position: relative;
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 2px;
            text-align: center;
            text-transform: uppercase;
            line-height: 1.3;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            animation: purgeFlash 3s ease-in-out;
            overflow: hidden;
        }

        .purge-flash::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
            animation: purgeFlashSweep 3s ease-in-out;
        }

        .purge-flash::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            animation: purgeFlashOverlay 3s ease-in-out;
            pointer-events: none;
        }

        @keyframes purgeFlash {
            0% { 
                background: rgba(0, 0, 0, 0.95);
                color: #ffffff;
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            }
            15% { 
                background: rgba(255, 255, 255, 0.98);
                color: #000000;
                box-shadow: 0 0 50px rgba(255, 255, 255, 1);
                border-color: rgba(0, 0, 0, 0.3);
            }
            30% { 
                background: rgba(255, 255, 255, 0.95);
                color: #000000;
                box-shadow: 0 0 60px rgba(255, 255, 255, 1);
            }
            45% { 
                background: rgba(255, 255, 255, 0.9);
                color: #000000;
                box-shadow: 0 0 40px rgba(255, 255, 255, 0.8);
            }
            70% { 
                background: rgba(200, 200, 200, 0.4);
                color: #ffffff;
                box-shadow: 0 0 35px rgba(255, 255, 255, 0.5);
                border-color: rgba(255, 255, 255, 0.6);
            }
            100% { 
                background: rgba(0, 0, 0, 0.95);
                color: #ffffff;
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
                border-color: rgba(255, 255, 255, 0.8);
            }
        }

        @keyframes purgeFlashSweep {
            0% { left: -100%; }
            20% { left: 100%; }
            100% { left: 100%; }
        }

        @keyframes purgeFlashOverlay {
            0% { background: rgba(255, 255, 255, 0); }
            15% { background: rgba(255, 255, 255, 0.3); }
            30% { background: rgba(255, 255, 255, 0.4); }
            70% { background: rgba(255, 255, 255, 0.1); }
            100% { background: rgba(255, 255, 255, 0); }
        }

        /* Removed chat bubble emoji - cleaner text message format */

        /* Pause markers - invisible but carry timing data */
        .pause-marker {
            display: none;
            visibility: hidden;
        }







        /* Enhanced mobile responsiveness */
        @media (max-width: 768px) {
            .header {
                padding: 15px;
                flex-wrap: wrap;
                gap: 10px;
            }

            .header-left {
                gap: 15px;
            }

            .logo {
                font-size: 18px;
            }

            .story-logo {
                font-size: 16px;
            }

            .control-buttons {
                gap: 4px;
            }

            .header-right {
                gap: 12px;
            }

            .story-container {
                padding: 0 15px;
                height: calc(100vh - 140px);
                margin-top: 120px;
            }
            
            .story-container {
                padding: 15px; /* Mobile margins */
            }
            
            .choices {
                min-height: 100px; /* Smaller minimum on mobile */
                max-height: 140px; /* Smaller maximum on mobile */
                padding: 10px 15px 20px 15px; /* Extra bottom padding for mobile */
                gap: 6px;
                position: sticky; /* Ensure choices stick to bottom of viewport */
                bottom: 0;
                z-index: 1000; /* Make sure it's above other content */
                margin-bottom: env(safe-area-inset-bottom, 0px); /* Account for iOS safe area */
            }
            
            .passage {
                padding: 20px;
            }
            
            .story-title {
                font-size: 24px;
            }
            
            .passage-text {
                font-size: 14px;
            }
            
            .header {
                padding: 15px;
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .control-buttons {
                flex-wrap: wrap;
                gap: 6px;
            }
            
            .choice-button {
                padding: 10px 12px;
                font-size: 12px;
                line-height: 1.3;
                min-height: 42px; /* Slightly smaller on mobile but still accessible */
            }
            
            .choice-button:hover {
                padding-left: 28px; /* Adjust for smaller mobile padding */
                transform: translateX(2px);
            }
            
            /* Special formatting mobile adjustments */
            .time-jump {
                font-size: 16px;
                letter-spacing: 2px;
                margin: 20px 0;
                padding: 12px 15px;
            }
            
            .console-message,
            .console-warning {
                font-size: 13px;
                padding: 10px 12px;
                margin: 12px 0;
            }
            
            .console-block {
                font-size: 13px;
                padding: 12px 15px;
                margin: 12px 0;
            }
            
            .ai-voice {
                font-size: 14px;
                padding: 12px 15px;
                margin: 12px 0;
            }

            .text-message {
                font-size: 13px;
                padding: 8px 12px;
                margin: 10px 0;
            }

            .log-entry {
                font-size: 13px;
                padding: 10px 14px;
                margin: 12px 0;
            }

            .helix-message {
                font-size: 13px;
                padding: 10px 14px;
                margin: 12px 0;
            }

            .system-message {
                font-size: 12px;
                padding: 10px 14px;
                margin: 12px 0;
                letter-spacing: 0.3px;
            }

            .purge-flash {
                font-size: 14px;
                padding: 16px 20px;
                margin: 20px 0;
                letter-spacing: 1.5px;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 10px;
            }
            
            .logo {
                font-size: 16px;
            }
            
            /* Ensure choices are always accessible on very small screens */
            .choices {
                position: fixed !important;
                bottom: 0;
                left: 0;
                right: 0;
                max-width: 100%;
                margin: 0;
                border-radius: 0;
                min-height: 140px !important; /* Ensure minimum height for choices */
                max-height: 200px !important; /* Allow more height on small screens */
                background: linear-gradient(to bottom, 
                    transparent 0%, 
                    rgba(10, 10, 15, 0.6) 10%,
                    rgba(10, 10, 15, 0.85) 30%, 
                    rgba(10, 10, 15, 0.95) 50%, 
                    rgba(10, 10, 15, 1) 100%
                );
                padding: 15px 15px calc(25px + env(safe-area-inset-bottom, 0px)) 15px !important;
                box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.8);
                overflow-y: auto; /* Allow scrolling if needed */
            }
            
            .choice-button {
                min-height: 48px !important; /* Ensure minimum touch target */
                padding: 12px 15px !important;
                font-size: 13px !important;
                line-height: 1.4 !important;
                white-space: normal !important; /* Allow text wrapping */
                word-wrap: break-word !important;
            }
            
            .story-container {
                padding-bottom: 220px !important; /* Extra space at bottom for larger fixed choices */
            }
            
            .control-btn {
                width: 28px;
                height: 28px;
                font-size: 10px;
            }
            
            .back-button {
                padding: 5px 10px;
                font-size: 10px;
                height: 28px;
            }
            
            .speed-control {
                padding: 5px 8px;
                font-size: 10px;
                height: 28px;
                min-width: 36px;
            }
            
            .show-all-btn {
                padding: 5px 10px;
                font-size: 10px;
                height: 28px;
                min-width: 54px;
            }

            .admin-access-btn {
                padding: 4px 6px;
                font-size: 10px;
                height: 28px;
            }
            
            .choice-button {
                padding: 10px 12px;
                font-size: 12px;
            }

            /* Admin panel mobile adjustments */
            .admin-panel {
                width: calc(100vw - 20px);
                right: 10px;
                left: 10px;
                transform: translateY(-50%);
                max-height: 70vh;
            }

            .admin-section select {
                width: 60%;
                font-size: 10px;
            }

            .admin-btn {
                font-size: 10px;
                padding: 4px 6px;
            }

            .admin-btn.small {
                font-size: 9px;
                padding: 3px 5px;
            }
            
            /* Special formatting for very small screens */
            .time-jump {
                font-size: 14px;
                letter-spacing: 1px;
                margin: 15px 0;
                padding: 10px 12px;
            }
            
            .console-message,
            .console-warning,
            .ai-voice {
                font-size: 12px;
                padding: 8px 10px;
                margin: 10px 0;
            }
            
            .console-block {
                font-size: 12px;
                padding: 10px 12px;
                margin: 10px 0;
            }

            .text-message {
                font-size: 12px;
                padding: 8px 10px;
                margin: 8px 0;
            }

            .log-entry {
                font-size: 12px;
                padding: 8px 12px;
                margin: 10px 0;
            }

            .helix-message {
                font-size: 12px;
                padding: 8px 12px;
                margin: 10px 0;
            }

            .system-message {
                font-size: 11px;
                padding: 8px 12px;
                margin: 10px 0;
                letter-spacing: 0.2px;
            }

            .purge-flash {
                font-size: 13px;
                padding: 14px 16px;
                margin: 16px 0;
                letter-spacing: 1px;
            }
        }

        /* Accessibility improvements */
        .choice-button:focus {
            outline: 2px solid #ff3b3b;
            outline-offset: 2px;
        }

                 .control-btn:focus,
         .speed-control:focus,
         .back-button:focus,
         .show-all-btn:focus {
             outline: 2px solid #ff3b3b;
             outline-offset: 2px;
         }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .passage {
                border-color: #fff;
                background: rgba(255, 255, 255, 0.1);
            }
            
            .choice-button {
                border-color: #fff;
                background: rgba(255, 255, 255, 0.1);
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .typing-cursor {
                animation: none;
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <div class="logo">Odysiq</div>
            <div class="story-logo glitch-text" data-text="Ghost Logic">Ghost Logic</div>
        </div>
        <div class="header-right">
            <div class="control-buttons">
                <button class="show-all-btn" id="showAllBtn" onclick="storyPlayer.toggleShowAll()" title="Switch between crawler mode and full scrolling view">Show All</button>
                <button class="speed-control" id="speedBtn" onclick="storyPlayer.cycleSpeed()" title="Reveal speed: Click to cycle between 0.75x, 1x, 1.25x, and 1.5x reading speeds">1x</button>
                <button class="control-btn" id="pausePlayBtn" onclick="storyPlayer.togglePause()" title="Pause or resume the text reveal animation">‚è∏</button>
                <button class="control-btn" id="restartBtn" onclick="storyPlayer.confirmRestart()" title="Start the story over from the beginning (will clear your saved progress)">‚Üª</button>
                <button class="admin-access-btn" id="adminAccessBtn" onclick="storyPlayer.toggleAdminPanel()" title="Admin Controls (Scene Navigation & Variables)" style="display: none;">üîß Admin</button>
                <a href="index.html" class="back-button" title="Return to the main story selection page">‚Üê Back</a>
            </div>
            <div class="auth-section">
                <!-- Signed out state -->
                <div class="auth-buttons" id="authButtons">
                    <button class="auth-btn" onclick="showAuthModal('signin')">Sign In</button>
                    <button class="auth-btn primary" onclick="showAuthModal('signup')">Sign Up</button>
                </div>
                
                <!-- Signed in state -->
                <div class="user-profile" id="userProfile">
                    <div class="user-avatar" id="userAvatar">U</div>
                    <div class="user-info">
                        <div class="user-name" id="userName">User</div>
                        <div class="user-email" id="userEmail">user@example.com</div>
                        <div class="admin-badge" id="adminBadge" style="display: none;">Admin</div>
                    </div>
                    <button class="sign-out-btn" onclick="handleSignOut()">Sign Out</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>

    <div class="story-container" id="storyContainer">
        <div class="content-area" id="contentArea">
            <!-- Content will be added here dynamically -->
        </div>
    </div>
    
    <!-- Fixed bottom choices section -->
    <div class="choices hidden" id="choicesContainer">
        <!-- Choices will be added here -->
    </div>

    <!-- Admin Panel -->
    <div class="admin-panel" id="adminPanel" style="display: none;">
        <div class="admin-header">
            <span class="admin-title">üîß Admin Controls</span>
            <button class="admin-toggle" onclick="storyPlayer.toggleAdminPanel()">√ó</button>
        </div>
        <div class="admin-content">
            <div class="admin-section">
                <label for="sceneSelect">Jump to Scene:</label>
                <select id="sceneSelect" onchange="storyPlayer.jumpToScene(this.value)">
                    <option value="">-- Select Scene --</option>
                </select>
                <button class="admin-btn" onclick="storyPlayer.refreshSceneList()">‚Üª</button>
            </div>
            <div class="admin-section">
                <label>Game Variables:</label>
                <div class="game-vars" id="gameVars">
                    <div class="no-vars">No variables set</div>
                </div>
                <button class="admin-btn small" onclick="storyPlayer.addGameVariable()">+ Add Variable</button>
                <button class="admin-btn small" onclick="storyPlayer.clearGameVariables()">Clear All</button>
            </div>
            <div class="admin-section">
                <label>Current Scene:</label>
                <div class="current-scene-info" id="currentSceneInfo">
                    <div>Name: <span id="adminCurrentScene">-</span></div>
                    <div>ID: <span id="adminSceneId">-</span></div>
                    <div>Tags: <span id="adminSceneTags">-</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scene Transition Overlay -->
    <div class="scene-transition" id="sceneTransition"></div>

    <!-- Scroll Indicator -->
    <div class="scroll-indicator" id="scrollIndicator"></div>

    <div class="state-info" id="stateInfo" style="display: none;">
        <div>Current Scene: <span id="currentScene">-</span></div>
        <div>Variables: <span id="currentVars">-</span></div>
    </div>

    <!-- Authentication Modal -->
    <div class="modal-overlay" id="authModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Welcome Back</h2>
                <p class="modal-subtitle" id="modalSubtitle">Sign in to continue your adventure</p>
            </div>
            
            <form id="authForm">
                <!-- Name field (only for signup) -->
                <div class="form-group" id="nameGroup" style="display: none;">
                    <label class="form-label" for="displayName">Full Name</label>
                    <input type="text" class="form-input" id="displayName" placeholder="Enter your full name">
                </div>
                
                <!-- Email field -->
                <div class="form-group">
                    <label class="form-label" for="email">Email Address</label>
                    <input type="email" class="form-input" id="email" placeholder="Enter your email address" required>
                </div>
                
                <!-- Password field -->
                <div class="form-group">
                    <label class="form-label" for="password">Password</label>
                    <input type="password" class="form-input" id="password" placeholder="Enter your password" required>
                </div>
                
                <!-- Admin checkbox (only for signup) -->
                <div class="checkbox-container" id="adminGroup" style="display: none;">
                    <input type="checkbox" class="checkbox-input" id="isAdmin">
                    <label class="checkbox-label" for="isAdmin">Grant admin access (for testing and development)</label>
                </div>
                
                <div class="form-buttons">
                    <button type="button" class="form-button secondary" onclick="closeAuthModal()">Cancel</button>
                    <button type="submit" class="form-button primary" id="submitButton">
                        <span class="loading-spinner"></span>
                        <span id="submitText">Sign In</span>
                    </button>
                </div>
                
                <div id="authMessage"></div>
            </form>
            
            <div class="auth-toggle">
                <a href="#" onclick="toggleAuthMode()" id="authToggleLink">
                    Don't have an account? Sign up
                </a>
            </div>
        </div>
    </div>

    <!-- Review Modal -->
    <div class="modal-overlay" id="reviewModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Rate Your Experience</h2>
                <p class="modal-subtitle">How did you like this journey through Ghost Logic?</p>
            </div>
            
            <div class="review-modal-content">
                <div class="star-rating" id="starRating">
                    <div class="star" data-rating="1" onclick="storyPlayer.setRating(1)">‚òÖ</div>
                    <div class="star" data-rating="2" onclick="storyPlayer.setRating(2)">‚òÖ</div>
                    <div class="star" data-rating="3" onclick="storyPlayer.setRating(3)">‚òÖ</div>
                    <div class="star" data-rating="4" onclick="storyPlayer.setRating(4)">‚òÖ</div>
                    <div class="star" data-rating="5" onclick="storyPlayer.setRating(5)">‚òÖ</div>
                </div>
                
                <textarea 
                    class="review-textarea" 
                    id="reviewComment" 
                    placeholder="Share your thoughts about the story... (optional)"
                    maxlength="500"
                ></textarea>
                
                <div class="form-buttons">
                    <button type="button" class="form-button secondary" onclick="storyPlayer.closeReviewModal()">Skip</button>
                    <button type="button" class="form-button primary" id="submitReview" onclick="storyPlayer.submitReview()" disabled>
                        <span id="submitText">Submit Review</span>
                    </button>
                </div>
                
                <div class="review-success" id="reviewSuccess" style="display: none;">
                    <div style="color: #00ffff; font-size: 18px; margin-bottom: 8px;">‚úì Review Submitted</div>
                    <div style="color: #888; font-size: 14px;">Thank you for your feedback!</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class StoryPlayer {
            constructor() {
                this.storyData = null;
                this.currentPassage = null;
                this.gameState = {};
                this.passageHistory = [];
                this.currentChoices = [];
                this.isTyping = false;
                this.isPaused = false;
                this.speedMultipliers = [0.75, 1.0, 1.25, 1.5]; // 75%, 100%, 125%, 150%
                this.currentSpeedIndex = 1; // Start at 100%
                this.revealSpeed = 400; // base milliseconds between paragraphs (adjusted for longer individual fades)
                this.typingInterval = null;
                this.currentText = '';
                this.displayedText = '';
                this.textIndex = 0;
                this.userIP = null;
                this.showAllMode = false;
                this.glitchTimer = null;
                this.animationsDisabled = false;
                this.init();
            }

            async init() {
                try {
                    await this.getUserIP();
                    await this.loadStoryData();
                    await this.loadProgress();
                    this.updateRevealSpeed();
                    this.updateSpeedButton();
                    this.startGlitchTimer();
                    this.startStory();
                } catch (error) {
                    console.error('Failed to load story:', error);
                    document.getElementById('story-content').innerHTML = 
                        `<div class="error">Failed to load story: ${error.message}<br><br>Please check the browser console for more details.</div>`;
                }
            }

            async getUserIP() {
                try {
                    // Use a simple IP service, fallback to a timestamp-based ID if unavailable
                    const response = await fetch('https://api.ipify.org?format=json');
                    const data = await response.json();
                    this.userIP = data.ip;
                } catch (error) {
                    console.log('Could not get IP, using fallback ID');
                    this.userIP = 'local_' + Date.now();
                }
                console.log('User ID:', this.userIP);
            }

            async loadStoryData() {
                console.log('Attempting to load Ghost-Logic.json...');
                try {
                    const response = await fetch('Ghost-Logic.json');
                    console.log('Fetch response:', response);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                    }
                    
                    const text = await response.text();
                    console.log('Raw response text length:', text.length);
                    console.log('First 500 chars:', text.substring(0, 500));
                    
                    this.storyData = JSON.parse(text);
                    console.log('JSON parsed successfully. Passages count:', this.storyData.passages?.length);
                } catch (error) {
                    console.error('Error in loadStoryData:', error);
                    throw error;
                }
            }

            async startStory() {
                console.log('Story data loaded:', this.storyData);
                
                if (!this.storyData.passages || !Array.isArray(this.storyData.passages)) {
                    throw new Error('Invalid story format: passages array not found');
                }
                
                // Check if we have saved progress
                if (this.currentPassage) {
                    console.log('Resuming from saved passage:', this.currentPassage.name);
                    await this.renderPassage();
                    this.updateStateInfo();
                    return;
                }
                
                // Find the starting passage - look for Scene 0, Scene 1, or the first passage
                const startPassage = this.storyData.passages.find(p => 
                    p.name.includes('Scene 0') || 
                    p.name.includes('Scene 1') || 
                    p.tags.includes('Start') ||
                    p.name.includes('Framed in Neon')
                ) || this.storyData.passages[0];

                console.log('Starting with passage:', startPassage);

                if (startPassage) {
                    this.goToPassage(startPassage.name);
                } else {
                    throw new Error('No starting passage found');
                }
            }

            makeChoice(choiceIndex) {
                if (!this.currentChoices || choiceIndex >= this.currentChoices.length) {
                    console.error('Invalid choice index:', choiceIndex);
                    return;
                }
                
                const choice = this.currentChoices[choiceIndex];
                console.log('Making choice:', choice);
                
                // Add choice feedback animation and loading state
                const choiceButton = document.querySelectorAll('.choice-button')[choiceIndex];
                if (choiceButton) {
                    this.highlightSelectedChoice(choiceButton);
                    // Add loading state to the selected button
                    setTimeout(() => {
                        choiceButton.classList.add('loading');
                    }, 150);
                }
                
                // Process any set commands from the choice
                if (choice.setCommands) {
                    this.processSetCommands(choice.setCommands);
                }
                
                // Navigate to the destination - immediate in show-all mode, delayed in crawler
                const delay = this.showAllMode ? 100 : 300;
                setTimeout(() => {
                    this.goToPassage(choice.destination);
                }, delay);
            }

            async goToPassage(passageName) {
                const passage = this.storyData.passages.find(p => p.name === passageName);
                if (!passage) {
                    console.error('Passage not found:', passageName);
                    return;
                }

                // Skip scene transition in show-all mode for smoother experience
                if (this.showAllMode) {
                    this.currentPassage = passage;
                    this.passageHistory.push(passageName);
                    
                    // Process any set commands in the passage text first
                    this.processSetCommands(passage.text);
                    
                    // Save progress
                    this.saveProgress();
                    
                    await this.renderPassage();
                    this.updateStateInfo();
                    this.updateShowAllButton();
                    
                    // Scroll to the new content in show-all mode
                    setTimeout(() => {
                        const contentArea = document.getElementById('contentArea');
                        if (contentArea) {
                            contentArea.scrollIntoView({ behavior: 'smooth', block: 'end' });
                        }
                    }, 100);
                } else {
                    // Normal scene transition for crawler mode
                    this.triggerSceneTransition(async () => {
                        this.currentPassage = passage;
                        this.passageHistory.push(passageName);
                        
                        // Process any set commands in the passage text first
                        this.processSetCommands(passage.text);
                        
                        // Save progress
                        this.saveProgress();
                        
                        await this.renderPassage();
                        this.updateStateInfo();
                        this.updateShowAllButton();
                        window.scrollTo(0, 0);
                    });
                }
            }

            async renderPassage() {
                console.log('Rendering passage:', this.currentPassage.name);
                
                // Check if paywall is required for Scene 13 specifically
                const paywallRequired = await checkPaywallRequired(this.currentPassage.name);
                if (paywallRequired) {
                    console.log('Paywall required for:', this.currentPassage.name);
                    return; // Don't render the scene
                }
                
                // Stop any existing typing animation
                this.stopTyping();
                
                // Extract choices and process text
                const choices = this.extractChoices();
                this.currentChoices = choices;
                this.currentText = this.processText(this.currentPassage.text);
                
                // Always clear and create fresh content area for new scenes
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '';
                
                // Create new passage element
                const passageElement = document.createElement('div');
                passageElement.classList.add('passage');
                
                const passageText = document.createElement('div');
                passageText.classList.add('passage-text');
                passageText.id = 'passageText';
                
                // Ensure clean state for crawler mode
                if (!this.showAllMode) {
                    passageText.style.opacity = '';
                    passageText.style.transform = '';
                    passageText.style.transition = '';
                }
                
                passageElement.appendChild(passageText);
                contentArea.appendChild(passageElement);
                
                // Update choices
                const choicesContainer = document.getElementById('choicesContainer');
                choicesContainer.innerHTML = this.renderChoicesFromExtracted(choices);
                
                if (this.showAllMode) {
                    // Show all mode: reveal complete text immediately
                    passageText.innerHTML = this.currentText;
                    
                    // Remove all fade effects
                    const allParagraphs = passageText.querySelectorAll('p');
                    allParagraphs.forEach(p => {
                        p.style.opacity = '1';
                        p.style.transform = 'translateY(0)';
                        p.style.transition = 'none';
                    });
                    
                    // Show choices immediately
                    choicesContainer.classList.remove('hidden');
                    choicesContainer.classList.add('visible');
                    
                    // Make choice buttons visible without animation
                    const choiceButtons = choicesContainer.querySelectorAll('.choice-button');
                    choiceButtons.forEach(button => {
                        button.classList.add('reveal');
                        button.style.transform = 'translateY(0)';
                        button.style.opacity = '1';
                    });
                } else {
                    // Crawler mode: hide choices and start typing animation
                    choicesContainer.classList.add('hidden');
                    choicesContainer.classList.remove('visible');
                    
                    // Start typing animation which will handle the crawler effect
                    this.startTyping();
                }
            }

            processText(text) {
                if (!text) return '<p>No text available</p>';
                
                console.log('Processing text with game state:', this.gameState);
                console.log('Original text length:', text.length);
                
                // Process conditional statements first
                let processed = this.evaluateConditionals(text);
                
                // Remove ALL link syntax from the display text since we handle choices separately
                processed = processed
                    // Remove complete link patterns: (link: "text")[content]
                    .replace(/\(link:\s*"[^"]+"\)\s*\[[^\]]*\]/g, '')
                    // Remove incomplete link patterns: (link: "text")[
                    .replace(/\(link:\s*"[^"]+"\)\s*\[/g, '')
                    // Remove set commands (already processed)
                    .replace(/\(set:[^)]*\)/g, '')
                    // Remove goto commands that aren't part of links
                    .replace(/\(goto:\s*"[^"]*"\)/g, '')
                    // Remove [[link]] syntax  
                    .replace(/\[\[([^\]]+)\]\]/g, '')
                    // Remove any remaining orphaned closing brackets
                    .replace(/^\s*\]\s*$/gm, '')
                    // Convert //text// to italics
                    .replace(/\/\/([^\/]+)\/\//g, '<em>$1</em>')
                    // Convert **text** to bold
                    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                    // Clean up extra whitespace but preserve structure
                    .replace(/\n\s*\n\s*\n/g, '\n\n')
                    .trim();
                
                // Process dialogue styling
                processed = this.processDialogue(processed);
                
                // Process special formatting for interactive elements
                processed = this.processSpecialFormatting(processed);
                
                // Convert to paragraphs
                const paragraphs = processed.split('\n\n').filter(p => p.trim().length > 0 && !p.match(/^[\[\]{}()\s]*$/));
                let formattedText = paragraphs.map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`).join('');
                
                // Clean up any remaining pause markers that might appear in paragraph breaks
                formattedText = formattedText.replace(/<span class="pause-marker"[^>]*><\/span>/g, '');
                formattedText = formattedText.replace(/<p>\s*<\/p>/g, ''); // Remove empty paragraphs that might be created

                console.log('Final processed text length:', formattedText.length);
                
                return formattedText || '<p>Continue...</p>';
            }

            processDialogue(text) {
                // Process different types of dialogue with color coding
                let processed = text;
                
                // First, detect HELIX system communications (highest priority)
                // Look for Helix-specific technical/clinical speech patterns
                processed = processed.replace(/"([^"]+)"/g, (match, dialogue) => {
                    const lowerDialogue = dialogue.toLowerCase();
                    
                    // Check for Helix-specific patterns
                    const helixPatterns = [
                        /neural sync|cognitive sync|sync at \d+%/i,
                        /cognitive lattice|lattice integrity|logic integration/i,
                        /host remains viable|host integration|host logic/i,
                        /predictive recursion|recursive mapping|recursive lattice/i,
                        /core logic stabilized|logic anchor detected/i,
                        /purge node|baseline virelli|termination imminent/i,
                        /cognitive resolution|cognitive bond/i,
                        /final alignment|final recursion/i
                    ];
                    
                    // Check for system status format (percentages, status updates)
                    const systemStatusPattern = /\d+%|stable|complete|detected|initiated|unlocked|armed/i;
                    const technicalTerms = /(neural|cognitive|sync|lattice|host|logic|recursive|core|baseline|purge|resolution|bond|alignment|integration)/i;
                    
                    // Determine if this is Helix speaking
                    const isHelixPattern = helixPatterns.some(pattern => pattern.test(dialogue));
                    const hasSystemStatus = systemStatusPattern.test(dialogue) && technicalTerms.test(dialogue);
                    const isSystemFormat = /^[A-Z][a-z]+ [a-z]+.*[.:]/.test(dialogue) && technicalTerms.test(dialogue);
                    
                    if (isHelixPattern || hasSystemStatus || isSystemFormat) {
                        // Return Helix dialogue without special formatting
                        return `<div class="helix-voice">${dialogue}</div>`;
                    }
                    
                    // Continue with other dialogue detection...
                    return match; // Return unchanged for now, will be processed by subsequent patterns
                });
                
                // Disabled automatic AI speech context detection to prevent formatting conflicts
                // Use [AI]text[/AI] tags instead for explicit AI voice formatting
                
                // Second, check for AI speech context patterns around quotes (DISABLED)
                // Look for patterns like "The AI said" or "the AI intoned" before quotes
                // processed = processed.replace(/(.*(?:AI|ai|voice|system|ghost|cipher).*?[.!?]\s*)"([^"]+)"/gi, (match, context, dialogue) => {
                //     // Skip if already processed as Helix
                //     if (match.includes('class="helix-voice"')) return match;
                //     // This is likely AI speech based on context
                //     return context + `<div class="ai-voice">"${dialogue}"</div>`;
                // });
                
                // Also catch quotes that immediately follow AI context without punctuation (DISABLED)
                // processed = processed.replace(/(.*(?:AI|ai|voice|system|ghost|cipher).*?)\s*"([^"]+)"/gi, (match, context, dialogue) => {
                //     // Skip if already processed as Helix or AI
                //     if (match.includes('class="helix-voice"') || match.includes('class="ai-voice"')) return match;
                //     // Skip if this was already processed above
                //     if (context.match(/[.!?]\s*$/)) return match;
                //     return context + ` <div class="ai-voice">"${dialogue}"</div>`;
                // });
                
                // Finally, detect remaining dialogue patterns and wrap them  
                // Pattern: "Text in quotes" (for remaining quotes not caught above)
                processed = processed.replace(/"([^"]+)"/g, (match, dialogue) => {
                    // Skip if already processed as Helix or AI
                    if (match.includes('class="helix-voice"') || match.includes('class="ai-voice"')) return match;
                    
                    // Skip if this appears to be quoted narrative/action text rather than spoken dialogue
                    // Look for action verbs, third-person narrative, or descriptive phrases
                    const narrativePatterns = [
                        /\b(leveled|mirrored|locked|moved|stepped|turned|raised|lowered|aimed|fired|drew|pulled|pushed|grabbed|held|watched|looked|stared|glanced)\b/i,
                        /\b(her weapon|his weapon|their weapon|eyes locked|motion|action|movement)\b/i,
                        /\b(Holloway|Ash|they|she|he)\s+(leveled|stepped|moved|turned|raised|lowered|aimed|fired|drew|pulled|pushed|grabbed|held|watched|looked|stared|glanced)\b/i,
                        /;\s*(Ash|Holloway|she|he|they)\s+/i, // semicolon followed by character name suggests narrative
                        /\b(weapon|motion|eyes|action|movement)\b.*\b(locked|leveled|mirrored|aimed|raised|lowered)\b/i
                    ];
                    
                    const isNarrative = narrativePatterns.some(pattern => pattern.test(dialogue));
                    
                    if (isNarrative) {
                        // Return the quote unchanged - it's narrative text, not dialogue
                        return match;
                    }
                    
                    // Disabled automatic dialogue formatting to prevent unwanted styling
                    // Use explicit formatting tags like [AI], [HELIX], etc. for special dialogue
                    return match; // Return the original quoted text unchanged
                });
                
                return processed;
            }

            processSpecialFormatting(text) {
                let processed = text;
                
                // [HIGHLIGHT]text[/HIGHLIGHT] - Neon highlight effect
                processed = processed.replace(/\[HIGHLIGHT\](.*?)\[\/HIGHLIGHT\]/g, '<span class="neon-highlight">$1</span>');
                
                // [TERM]text[/TERM] - Interactive term with hover effect
                processed = processed.replace(/\[TERM\](.*?)\[\/TERM\]/g, '<span class="interactive-term">$1</span>');
                
                // [DISCOVERY]text[/DISCOVERY] - Special discovery formatting
                processed = processed.replace(/\[DISCOVERY\](.*?)\[\/DISCOVERY\]/g, '<span class="discovery-text">$1</span>');
                
                // [TIMEJUMP]text[/TIMEJUMP] - Time jump formatting (like "4 Years Later") with 5-second pause
                processed = processed.replace(/\[TIMEJUMP\](.*?)\[\/TIMEJUMP\]/g, '<div class="time-jump" data-pause="5000">$1</div>');
                
                // [CONSOLE]multi-line content[/CONSOLE] - Multi-line computer console message (process first)
                processed = processed.replace(/\[CONSOLE\]([\s\S]*?)\[\/CONSOLE\]/g, (match, content) => {
                    // Check if content contains newlines (multi-line)
                    if (content.includes('\n')) {
                        // Multi-line console block
                        const lines = content.trim().split('\n').map(line => line.trim()).filter(line => line.length > 0);
                        const formattedLines = lines.map(line => {
                            // Lines that start with '>' keep the '>', others get no prefix
                            if (line.startsWith('>')) {
                                return `<div class="console-line prompt">${line}</div>`;
                            } else {
                                return `<div class="console-line">${line}</div>`;
                            }
                        }).join('');
                        return `<div class="console-block">${formattedLines}</div>`;
                    } else {
                        // Single line console message (original behavior)
                        return `<div class="console-message">${content}</div>`;
                    }
                });
                
                // [CONSOLE-BLINK]text[/CONSOLE-BLINK] - Console message with blinking cursor
                processed = processed.replace(/\[CONSOLE-BLINK\](.*?)\[\/CONSOLE-BLINK\]/g, '<div class="console-message blinking">$1</div>');
                
                // [WARNING]text[/WARNING] - Warning console message
                processed = processed.replace(/\[WARNING\](.*?)\[\/WARNING\]/g, '<div class="console-warning">$1</div>');
                
                // [AI]text[/AI] - AI voice speaking
                processed = processed.replace(/\[AI\](.*?)\[\/AI\]/g, '<div class="ai-voice">$1</div>');
                
                // [AI-PROCESS]text[/AI-PROCESS] - AI voice with processing animation
                processed = processed.replace(/\[AI-PROCESS\](.*?)\[\/AI-PROCESS\]/g, '<div class="ai-voice processing">$1</div>');
                
                // [TEXT]message content[/TEXT] - Text message format (supports multi-line)
                processed = processed.replace(/\[TEXT\]([\s\S]*?)\[\/TEXT\]/g, (match, content) => {
                    // Handle multi-line content and convert \n to <br>
                    const formattedContent = content
                        .replace(/\\n/g, '<br>') // Convert \n to line breaks
                        .replace(/''([^']+)''/g, '<strong>$1</strong>') // Convert ''text'' to bold
                        .trim();
                    return `<div class="text-message">${formattedContent}</div>`;
                });
                
                // [LOG]log content[/LOG] - Log entry format for complete log entries
                processed = processed.replace(/\[LOG\]([\s\S]*?)\[\/LOG\]/g, (match, content) => {
                    // Handle multi-line content and convert formatting
                    const formattedContent = content
                        .replace(/\\n/g, '<br>') // Convert \n to line breaks
                        .replace(/''([^']+)''/g, '<strong class="log-header">$1</strong>') // Convert ''text'' to bold log header
                        .replace(/\/\/([^\/]+)\/\//g, '<em class="log-emphasis">$1</em>') // Convert //text// to italics
                        .trim();
                    return `<div class="log-entry">${formattedContent}</div>`;
                });
                
                // [HELIX]helix content[/HELIX] - HELIX system message format (advanced version)
                processed = processed.replace(/\[HELIX\]([\s\S]*?)\[\/HELIX\]/g, (match, content) => {
                    // Handle multi-line content and convert formatting
                    const formattedContent = content
                        .replace(/\\n/g, '<br>') // Convert \n to line breaks
                        .replace(/''([^']+)''/g, '<strong class="helix-header">$1</strong>') // Convert ''text'' to bold header
                        .replace(/\/\/([^\/]+)\/\//g, '<em class="helix-emphasis">$1</em>') // Convert //text// to italics
                        .trim();
                    return `<div class="helix-message">${formattedContent}</div>`;
                });
                
                // [SYSTEM]system content[/SYSTEM] - Cold system message format
                processed = processed.replace(/\[SYSTEM\]([\s\S]*?)\[\/SYSTEM\]/g, (match, content) => {
                    // Handle multi-line content and convert formatting
                    const formattedContent = content
                        .replace(/\\n/g, '<br>') // Convert \n to line breaks
                        .replace(/''([^']+)''/g, '<strong class="system-header">$1</strong>') // Convert ''text'' to bold header
                        .replace(/\/\/([^\/]+)\/\//g, '<em class="system-emphasis">$1</em>') // Convert //text// to italics
                        .trim();
                    return `<div class="system-message">${formattedContent}</div>`;
                });
                
                // [PURGE]text[/PURGE] - Screen flash effect for dramatic system executions
                processed = processed.replace(/\[PURGE\]([\s\S]*?)\[\/PURGE\]/g, (match, content) => {
                    const formattedContent = content
                        .replace(/\\n/g, '<br>') // Convert \n to line breaks
                        .trim();
                    return `<div class="purge-flash">${formattedContent}</div>`;
                });
                
                // [PAUSE] - Creates a 3-second pause in the text reveal (stacks with multiple uses)
                processed = processed.replace(/\[PAUSE\]/g, '<span class="pause-marker" data-pause="3000"></span>');
                
                return processed;
            }

            processSetCommands(text) {
                // Extract and execute set commands
                const setPattern = /\(set:\s*\$(\w+)\s+to\s+"([^"]+)"\)/g;
                setPattern.lastIndex = 0; // Reset regex index
                let match;
                while ((match = setPattern.exec(text)) !== null) {
                    const varName = match[1];
                    const varValue = match[2];
                    this.gameState[varName] = varValue;
                    console.log(`Set variable: $${varName} = "${varValue}"`);
                }
                
                // Also handle set commands with non-quoted values
                const setPattern2 = /\(set:\s*\$(\w+)\s+to\s+([^)]+)\)/g;
                setPattern2.lastIndex = 0; // Reset regex index
                while ((match = setPattern2.exec(text)) !== null) {
                    const varName = match[1];
                    const varValue = match[2].trim().replace(/"/g, '');
                    if (varValue !== this.gameState[varName]) { // Avoid duplicates
                        this.gameState[varName] = varValue;
                        console.log(`Set variable: $${varName} = ${varValue}`);
                    }
                }
                
                // Debug: show current game state after processing
                console.log('Game state after processing set commands:', this.gameState);
            }

            evaluateConditionals(text) {
                console.log('Evaluating conditionals...');
                console.log('Current game state:', this.gameState);
                
                let processed = text;
                
                // Handle complex if/else-if/else chains first
                // Pattern: (if: condition)[content](else-if: condition)[content](else)[content] or similar
                const complexConditionalPattern = /\(if:\s*([^)]+)\)\s*\[([\s\S]*?)\](?:\s*\n)*\s*(?:\(else-if:\s*([^)]+)\)\s*\[([\s\S]*?)\](?:\s*\n)*)*\s*(?:\(else\)\s*\[([\s\S]*?)\])?\s*\]/g;
                
                processed = processed.replace(complexConditionalPattern, (match) => {
                    console.log('Processing complex conditional block:', match.substring(0, 200) + '...');
                    return this.processConditionalBlock(match);
                });
                
                // Handle simple if/else-if chains without final else
                const ifElseIfPattern = /\(if:\s*([^)]+)\)\s*\[([\s\S]*?)\]\s*\n*\s*\(else-if:\s*([^)]+)\)\s*\[([\s\S]*?)\]\]/g;
                
                processed = processed.replace(ifElseIfPattern, (match, ifCondition, ifContent, elseIfCondition, elseIfContent) => {
                    console.log('Processing if/else-if block:', { ifCondition, elseIfCondition });
                    
                    if (this.evaluateCondition(ifCondition)) {
                        console.log('If condition TRUE, using if branch');
                        return ifContent;
                    } else if (this.evaluateCondition(elseIfCondition)) {
                        console.log('Else-if condition TRUE, using else-if branch');
                        return elseIfContent;
                    } else {
                        console.log('No conditions met, returning empty');
                        return '';
                    }
                });
                
                // Handle complete if/else blocks properly (without ** markers)
                // Look for patterns like: (if: condition)[content](else)[content]
                const ifElsePattern = /\(if:\s*([^)]+)\)\s*\[([\s\S]*?)\]\s*\n*\s*\(else\)\s*\[([\s\S]*?)\]/g;
                
                processed = processed.replace(ifElsePattern, (match, condition, ifContent, elseContent) => {
                    console.log('Processing if/else block:', { condition, ifContent: ifContent.substring(0, 50), elseContent: elseContent.substring(0, 50) });
                    
                    if (this.evaluateCondition(condition)) {
                        console.log('If condition TRUE, using if branch');
                        return ifContent;
                    } else {
                        console.log('If condition FALSE, using else branch');
                        return elseContent;
                    }
                });
                
                // Handle if blocks without else (without ** markers)
                const ifOnlyPattern = /\(if:\s*([^)]+)\)\s*\[([\s\S]*?)\]/g;
                
                processed = processed.replace(ifOnlyPattern, (match, condition, content) => {
                    console.log('Processing if-only block:', { condition, content: content.substring(0, 50) });
                    
                    if (this.evaluateCondition(condition)) {
                        console.log('If-only condition TRUE, using content');
                        return content;
                    } else {
                        console.log('If-only condition FALSE, removing content');
                        return '';
                    }
                });
                
                // Handle any remaining ** wrapped conditionals (legacy support)
                const legacyIfElsePattern = /\*\*\(if:\s*([^)]+)\)\s*\[\s*([\s\S]*?)\s*\]\*\*\s*\*\*\(else\)\s*\[\s*([\s\S]*?)\s*\]\*\*/g;
                processed = processed.replace(legacyIfElsePattern, (match, condition, ifContent, elseContent) => {
                    if (this.evaluateCondition(condition)) {
                        return ifContent;
                    } else {
                        return elseContent;
                    }
                });
                
                const legacyIfOnlyPattern = /\*\*\(if:\s*([^)]+)\)\s*\[\s*([\s\S]*?)\s*\]\*\*/g;
                processed = processed.replace(legacyIfOnlyPattern, (match, condition, content) => {
                    if (this.evaluateCondition(condition)) {
                        return content;
                    } else {
                        return '';
                    }
                });
                
                // Handle orphaned else blocks (should be removed)
                processed = processed.replace(/\*\*\(else\)\s*\[\s*([\s\S]*?)\s*\]\*\*/g, '');
                
                // Clean up any remaining conditional syntax
                processed = processed
                    .replace(/\(if:\s*[^)]+\)\s*\[/g, '')
                    .replace(/\(else-if:\s*[^)]+\)\s*\[/g, '')
                    .replace(/\(else:\)\s*\[/g, '')
                    .replace(/^\s*\]\s*$/gm, '') // Remove standalone closing brackets
                    .replace(/\n\s*\n\s*\n/g, '\n\n'); // Clean up extra newlines
                
                return processed;
            }
            
            processConditionalBlock(blockText) {
                console.log('Processing conditional block:', blockText.substring(0, 100) + '...');
                
                // Extract all parts of the conditional by finding each section
                const parts = [];
                
                // Find the main if condition first
                const ifMatch = /\(if:\s*([^)]+)\)\s*\[([\s\S]*?)\]/.exec(blockText);
                if (ifMatch) {
                    // Find where the if content ends by looking for the next condition or end
                    const fullIfMatch = /\(if:\s*([^)]+)\)\s*\[([\s\S]*?)\](?=\s*(?:\(else-if:|\]|$))/.exec(blockText);
                    if (fullIfMatch) {
                        parts.push({
                            type: 'if',
                            condition: fullIfMatch[1],
                            content: fullIfMatch[2]
                        });
                        console.log('Found if condition:', fullIfMatch[1]);
                    }
                }
                
                // Find all else-if conditions
                const elseIfPattern = /\(else-if:\s*([^)]+)\)\s*\[([\s\S]*?)\](?=\s*(?:\]|$))/g;
                let elseIfMatch;
                while ((elseIfMatch = elseIfPattern.exec(blockText)) !== null) {
                    parts.push({
                        type: 'else-if',
                        condition: elseIfMatch[1],
                        content: elseIfMatch[2]
                    });
                    console.log('Found else-if condition:', elseIfMatch[1]);
                }
                
                // Find else condition (no condition, just content)
                const elseMatch = /\(else\)\s*\[([\s\S]*?)\]\s*\]/s.exec(blockText);
                if (elseMatch) {
                    parts.push({
                        type: 'else',
                        content: elseMatch[1]
                    });
                    console.log('Found else branch');
                }
                
                console.log('Total conditional parts found:', parts.length);
                
                // Evaluate conditions and return appropriate content
                for (const part of parts) {
                    if (part.type === 'else') {
                        console.log('Using else branch');
                        return part.content;
                    } else if (this.evaluateCondition(part.condition)) {
                        console.log(`${part.type} condition "${part.condition}" TRUE, using ${part.type} branch`);
                        return part.content;
                    } else {
                        console.log(`${part.type} condition "${part.condition}" FALSE, continuing...`);
                    }
                }
                
                console.log('No conditions met, returning empty');
                return '';
            }

            evaluateCondition(condition) {
                console.log('Evaluating condition:', condition);
                
                // Handle "is true" boolean checks: $variable is true
                const isTrueMatch = /\$(\w+)\s+is\s+true/.exec(condition);
                if (isTrueMatch) {
                    const varName = isTrueMatch[1];
                    const actualValue = this.gameState[varName];
                    const result = actualValue === true || actualValue === 'true';
                    console.log(`Condition: $${varName} is true | Actual: "${actualValue}" | Result: ${result}`);
                    return result;
                }
                
                // Handle "is false" boolean checks: $variable is false
                const isFalseMatch = /\$(\w+)\s+is\s+false/.exec(condition);
                if (isFalseMatch) {
                    const varName = isFalseMatch[1];
                    const actualValue = this.gameState[varName];
                    const result = actualValue === false || actualValue === 'false' || !actualValue;
                    console.log(`Condition: $${varName} is false | Actual: "${actualValue}" | Result: ${result}`);
                    return result;
                }
                
                // Handle "is" comparisons: $variable is "value"
                const isMatch = /\$(\w+)\s+is\s+"([^"]+)"/.exec(condition);
                if (isMatch) {
                    const varName = isMatch[1];
                    const expectedValue = isMatch[2];
                    const actualValue = this.gameState[varName];
                    const result = actualValue === expectedValue;
                    console.log(`Condition: $${varName} is "${expectedValue}" | Actual: "${actualValue}" | Result: ${result}`);
                    return result;
                }
                
                // Handle simple variable existence checks: $variable
                const simpleVarMatch = /\$(\w+)/.exec(condition);
                if (simpleVarMatch) {
                    const varName = simpleVarMatch[1];
                    const actualValue = this.gameState[varName];
                    const result = !!actualValue; // Convert to boolean
                    console.log(`Condition: $${varName} (existence check) | Actual: "${actualValue}" | Result: ${result}`);
                    return result;
                }
                
                console.log('Condition not recognized, defaulting to false');
                return false;
            }

            renderChoicesFromExtracted(choices) {
                console.log('Rendering choices:', choices);
                
                if (choices.length === 0) {
                    // Check if this is one of the excluded endings
                    const excludedEndings = ['TurnMyselfIn', 'Collateral (END B-)*'];
                    const currentPassageName = this.currentPassage ? this.currentPassage.name : '';
                    const isExcludedEnding = excludedEndings.some(ending => currentPassageName.includes(ending));
                    
                    if (isExcludedEnding) {
                        // Show simple ending without review system for excluded endings
                        return `<div class="choices">
                            <div style="text-align: center; color: #888; padding: 20px 20px 10px 20px;">End of story</div>
                            <button class="choice-button restart-button" onclick="storyPlayer.confirmRestart()" style="margin: 0 auto; display: block; background: rgba(0, 255, 255, 0.1); border-color: rgba(0, 255, 255, 0.3); color: #00ffff;">
                                ‚Üª Start Over
                            </button>
                        </div>`;
                    } else {
                        // Show review button and restart for all other endings
                        return `<div class="choices">
                            <div style="text-align: center; color: #888; padding: 20px 20px 15px 20px;">End of story</div>
                            
                            <div style="display: flex; gap: 12px; justify-content: center; align-items: center;">
                                <button class="choice-button review-trigger-button" onclick="storyPlayer.openReviewModal()" style="flex: 1; max-width: 180px; background: linear-gradient(135deg, rgba(0, 255, 255, 0.15), rgba(0, 150, 255, 0.1)); border-color: rgba(0, 255, 255, 0.4); color: #00ffff; box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);">
                                    ‚≠ê Rate Experience
                                </button>
                                
                                <button class="choice-button restart-button" onclick="storyPlayer.confirmRestart()" style="flex: 1; max-width: 140px; background: rgba(0, 255, 255, 0.1); border-color: rgba(0, 255, 255, 0.3); color: #00ffff;">
                                    ‚Üª Start Over
                                </button>
                            </div>
                        </div>`;
                    }
                }

                const choicesHtml = choices.map((choice, index) => 
                    `<button class="choice-button" onclick="storyPlayer.makeChoice(${index})">
                        ${choice.text}
                    </button>`
                ).join('');

                return `<div class="choices">${choicesHtml}</div>`;
            }

            extractChoices() {
                const choices = [];
                const choiceSet = new Set(); // To avoid duplicates
                
                console.log('Extracting choices from passage:', this.currentPassage.name);
                console.log('Game state:', this.gameState);
                console.log('Original text preview:', this.currentPassage.text.substring(0, 200) + '...');
                
                // Debug logging for choice extraction
                console.log('Passage name:', this.currentPassage.name);
                console.log('Text contains links:', /\(link:\s*"[^"]+"\)/.test(this.currentPassage.text));
                
                const originalText = this.currentPassage.text;
                
                // Strategy: Extract ALL potential choices from original text, 
                // then filter based on conditional visibility
                
                // Pattern 1: [[choice text->destination]]
                const simpleLinkPattern = /\[\[([^-\]]+)->([^\]]+)\]\]/g;
                let match;
                while ((match = simpleLinkPattern.exec(originalText)) !== null) {
                    const choiceText = match[1].trim();
                    const destination = match[2].trim();
                    const choiceKey = `${choiceText}-->${destination}`;
                    
                    if (!choiceSet.has(choiceKey) && this.isChoiceVisible(match[0], originalText)) {
                        choices.push({
                            text: choiceText,
                            destination: destination
                        });
                        choiceSet.add(choiceKey);
                        console.log('Added simple link choice:', choiceText, '->', destination);
                    }
                }
                
                // Pattern 2: Look for incomplete links - (link: "text")[ without closing ] - now handles multi-line
                const incompleteLinkPattern = /\(link:\s*"([^"]+)"\)\s*\[/g;
                while ((match = incompleteLinkPattern.exec(originalText)) !== null) {
                    const choiceText = match[1];
                    
                    if (this.isChoiceVisible(match[0], originalText)) {
                        console.log('Found visible incomplete link:', choiceText);
                        
                        // First try to find the complete link by looking ahead from this position
                        const startPos = match.index;
                        const linkStart = originalText.substring(startPos);
                        const completeMatch = /\(link:\s*"([^"]+)"\)\s*\[([\s\S]*?)\]/g.exec(linkStart);
                        
                        if (completeMatch) {
                            const linkBody = completeMatch[2];
                            const gotoMatch = /\(goto:\s*"([^"]+)"\)/.exec(linkBody);
                            if (gotoMatch) {
                                const destination = gotoMatch[1];
                                const choiceKey = `${choiceText}-->${destination}`;
                                if (!choiceSet.has(choiceKey)) {
                                    choices.push({
                                        text: choiceText,
                                        destination: destination,
                                        setCommands: linkBody
                                    });
                                    choiceSet.add(choiceKey);
                                    console.log('Added choice from incomplete->complete link:', choiceText, '->', destination);
                                    continue; // Skip the fallback logic below
                                }
                            }
                        }
                        
                        // Fallback: Look for corresponding passage in the links array
                        if (this.currentPassage.links && this.currentPassage.links.length > 0) {
                            // Find matching link by text similarity
                            const matchingLink = this.currentPassage.links.find(link => 
                                link.linkText === choiceText || 
                                link.linkText.includes(choiceText) ||
                                choiceText.includes(link.linkText)
                            ) || this.currentPassage.links[0];
                            
                            if (matchingLink) {
                                const choiceKey = `${choiceText}-->${matchingLink.passageName}`;
                                if (!choiceSet.has(choiceKey)) {
                                    choices.push({
                                        text: choiceText,
                                        destination: matchingLink.passageName
                                    });
                                    choiceSet.add(choiceKey);
                                    console.log('Added choice from incomplete link fallback:', choiceText, '->', matchingLink.passageName);
                                }
                            }
                        }
                    }
                }
                
                // Pattern 3: Complete links - (link: "choice text")[(set: $var to "value")(goto: "destination")]
                // Use a more aggressive pattern that handles multi-line content and works with our specific JSON structure
                // Reset regex lastIndex to avoid issues with global regex
                const completeLinkPattern = /\(link:\s*"([^"]+)"\)\s*\[([\s\S]*?)\]/gm;
                completeLinkPattern.lastIndex = 0;
                let completeLinkMatches = 0;
                
                // Special handling for Gala of Glass scene - extract the exact links we know exist
                if (this.currentPassage.name.includes('Gala of Glass')) {
                    console.log('=== GALA OF GLASS SPECIAL HANDLING ===');
                    
                    // Manually extract the two known choices from this scene
                    const galaChoices = [
                        {
                            text: "Enter through the gala floor. Confront Holloway directly and draw attention.",
                            destination: "Penthouse Parley (Scene 26A)",
                            setCommands: '(set: $skyspireApproach to "gala")\n(goto: "Penthouse Parley (Scene 26A)")'
                        },
                        {
                            text: "Slip into the systems core. Stay quiet. Hit Helix from inside.",
                            destination: "Control-Room Hijack (Scene 27)",
                            setCommands: '(set: $skyspireApproach to "systems")\n(goto: "Control-Room Hijack (Scene 27)")'
                        }
                    ];
                    
                    // Add these choices if they don't already exist
                    galaChoices.forEach(galaChoice => {
                        const choiceKey = `${galaChoice.text}-->${galaChoice.destination}`;
                        if (!choiceSet.has(choiceKey)) {
                            choices.push(galaChoice);
                            choiceSet.add(choiceKey);
                            console.log('Added hardcoded Gala choice:', galaChoice.text, '->', galaChoice.destination);
                        }
                    });
                    
                    console.log('Gala of Glass special handling complete, choices found:', choices.length);
                }
                
                // Continue with normal pattern matching for other scenes
                while ((match = completeLinkPattern.exec(originalText)) !== null) {
                    completeLinkMatches++;
                    const choiceText = match[1];
                    const linkBody = match[2];
                    
                    // Debug for Gala of Glass
                    if (this.currentPassage.name.includes('Gala of Glass')) {
                        console.log(`Complete link match ${completeLinkMatches}:`, {
                            choiceText,
                            linkBody: linkBody.substring(0, 100) + '...',
                            fullMatch: match[0].substring(0, 200) + '...'
                        });
                    }
                    
                    if (this.isChoiceVisible(match[0], originalText)) {
                        // Extract goto destination
                        const gotoMatch = /\(goto:\s*"([^"]+)"\)/.exec(linkBody);
                        if (gotoMatch) {
                            const destination = gotoMatch[1];
                            const choiceKey = `${choiceText}-->${destination}`;
                            if (!choiceSet.has(choiceKey)) {
                                choices.push({
                                    text: choiceText,
                                    destination: destination,
                                    setCommands: linkBody
                                });
                                choiceSet.add(choiceKey);
                                console.log('Added complete link choice:', choiceText, '->', destination);
                            }
                        } else {
                            console.log('No goto found in linkBody:', linkBody);
                        }
                    } else {
                        console.log('Choice not visible:', choiceText);
                    }
                }
                
                if (this.currentPassage.name.includes('Gala of Glass')) {
                    console.log('Total complete link matches found:', completeLinkMatches);
                }
                
                // Additional pattern for links where the closing ] might be on a separate line
                const separateClosingPattern = /\(link:\s*"([^"]+)"\)\s*\[\s*([\s\S]*?)\s*\]/gm;
                separateClosingPattern.lastIndex = 0;
                while ((match = separateClosingPattern.exec(originalText)) !== null) {
                    const choiceText = match[1];
                    const linkBody = match[2];
                    const choiceKey = `${choiceText}-->${linkBody}`;
                    
                    // Only add if not already found by previous patterns
                    if (!choiceSet.has(choiceKey) && this.isChoiceVisible(match[0], originalText)) {
                        const gotoMatch = /\(goto:\s*"([^"]+)"\)/.exec(linkBody);
                        if (gotoMatch) {
                            const destination = gotoMatch[1];
                            const finalChoiceKey = `${choiceText}-->${destination}`;
                            if (!choiceSet.has(finalChoiceKey)) {
                                choices.push({
                                    text: choiceText,
                                    destination: destination,
                                    setCommands: linkBody
                                });
                                choiceSet.add(finalChoiceKey);
                                console.log('Added separated closing bracket choice:', choiceText, '->', destination);
                            }
                        }
                    }
                }
                
                // Pattern 4: Auto-link pattern (only if no other choices found)
                if (choices.length === 0) {
                    const autoLinkPattern = /\[\[([^\]]+)\]\]/g;
                    while ((match = autoLinkPattern.exec(originalText)) !== null) {
                        if (this.isChoiceVisible(match[0], originalText)) {
                            const choiceKey = `${match[1].trim()}-->${match[1].trim()}`;
                            if (!choiceSet.has(choiceKey)) {
                                choices.push({
                                    text: match[1].trim(),
                                    destination: match[1].trim()
                                });
                                choiceSet.add(choiceKey);
                            }
                        }
                    }
                }
                
                // Fallback: Use passage links if no choices found
                if (choices.length === 0 && this.currentPassage.links && this.currentPassage.links.length > 0) {
                    console.log('No choices found, using passage links as fallback...');
                    
                    this.currentPassage.links.forEach((link) => {
                        const choiceKey = `${link.linkText || 'Continue'}-->${link.passageName}`;
                        if (!choiceSet.has(choiceKey)) {
                            choices.push({
                                text: link.linkText || 'Continue',
                                destination: link.passageName
                            });
                            choiceSet.add(choiceKey);
                        }
                    });
                }
                
                // Final deduplication for Continue buttons
                const uniqueChoices = [];
                const destinationSet = new Set();
                
                for (const choice of choices) {
                    if (choice.text.toLowerCase().includes('continue')) {
                        if (!destinationSet.has(choice.destination)) {
                            uniqueChoices.push(choice);
                            destinationSet.add(choice.destination);
                        }
                    } else {
                        uniqueChoices.push(choice);
                    }
                }
                
                console.log('Final choices after deduplication:', uniqueChoices);
                console.log('Total choices found:', uniqueChoices.length);
                uniqueChoices.forEach((choice, index) => {
                    console.log(`Choice ${index + 1}: "${choice.text}" -> "${choice.destination}"`);
                });
                
                // Special debug summary for Gala of Glass
                if (this.currentPassage.name.includes('Gala of Glass')) {
                    console.log('=== GALA OF GLASS EXTRACTION SUMMARY ===');
                    console.log('Expected 2 choices, found:', uniqueChoices.length);
                    if (uniqueChoices.length === 0) {
                        console.log('‚ùå NO CHOICES EXTRACTED - There is a problem with the extraction logic');
                    } else {
                        console.log('‚úÖ Choices extracted successfully');
                    }
                    console.log('=============================================');
                }
                
                return uniqueChoices;
            }

            // Helper method to determine if a choice should be visible based on conditional context
            isChoiceVisible(choiceText, fullText) {
                // Find which conditional block (if any) contains this choice
                const choiceIndex = fullText.indexOf(choiceText);
                if (choiceIndex === -1) {
                    return true;
                }
                
                // Look backwards to find the nearest conditional statement
                const beforeChoice = fullText.substring(0, choiceIndex);
                
                // Find the last conditional statement before this choice
                const ifMatches = [...beforeChoice.matchAll(/\(if:\s*([^)]+)\)/g)];
                const elseIfMatches = [...beforeChoice.matchAll(/\(else-if:\s*([^)]+)\)/g)];
                const elseMatches = [...beforeChoice.matchAll(/\(else:\)/g)];
                
                // Combine and sort by position
                const allConditionals = [
                    ...ifMatches.map(m => ({ type: 'if', condition: m[1], index: m.index })),
                    ...elseIfMatches.map(m => ({ type: 'else-if', condition: m[1], index: m.index })),
                    ...elseMatches.map(m => ({ type: 'else', condition: null, index: m.index }))
                ].sort((a, b) => b.index - a.index);
                
                // If no conditionals found before this choice, it's visible
                if (allConditionals.length === 0) {
                    return true;
                }
                
                // Check the most recent conditional
                const lastConditional = allConditionals[0];
                
                if (lastConditional.type === 'else') {
                    // For else blocks, check if all previous conditions in the chain failed
                    return this.shouldShowElseBranch(beforeChoice, choiceIndex);
                } else {
                    // For if/else-if, evaluate the condition
                    return this.evaluateCondition(lastConditional.condition);
                }
            }
            
            shouldShowElseBranch(textBeforeChoice, choiceIndex) {
                // This is a simplified check - in a full implementation you'd need to 
                // trace back through the entire if/else-if/else chain
                // For now, we'll check recent if/else-if conditions
                
                const recentConditionals = [...textBeforeChoice.matchAll(/\((?:if|else-if):\s*([^)]+)\)/g)];
                if (recentConditionals.length === 0) return true;
                
                // Check the most recent if/else-if condition
                const lastCondition = recentConditionals[recentConditionals.length - 1][1];
                return !this.evaluateCondition(lastCondition);
            }

            // Typing animation methods - now implements crawler effect
            startTyping() {
                // In show-all mode, content is already rendered, just show choices
                if (this.showAllMode) {
                    this.finishTyping();
                    return;
                }
                
                this.isTyping = true;
                this.updatePauseButton();
                
                // Hide choices initially in crawler mode
                const choicesContainer = document.getElementById('choicesContainer');
                if (choicesContainer) {
                    choicesContainer.classList.add('hidden');
                    choicesContainer.classList.remove('visible');
                }
                
                // Split text into paragraphs and type them one by one
                const paragraphs = this.currentText.split('</p>').filter(p => p.trim().length > 0);
                this.typeParagraphSequence(paragraphs, 0);
            }

            async typeParagraphSequence(paragraphs, index) {
                if (index >= paragraphs.length) {
                    this.finishTyping();
                    return;
                }

                // Clean up the paragraph text
                let paragraphText = paragraphs[index].replace('<p>', '').trim();
                if (paragraphText) {
                    // Check for special reveal types in the text
                    if (paragraphText.includes('[GLITCH]')) {
                        // Remove the marker and use glitch reveal
                        paragraphText = paragraphText.replace('[GLITCH]', '');
                        await this.revealParagraphWithGlitch(paragraphText);
                    } else {
                        // Default smooth fade reveal
                        await this.revealParagraphWithFade(paragraphText);
                    }
                    
                    // Only apply crawler fade if we're in crawler mode and actively typing
                    if (!this.showAllMode && this.isTyping) {
                        this.applyCrawlerFade();
                    }
                }

                // Continue with next paragraph with character-based timing
                if (this.isTyping && !this.isPaused) {
                    // Calculate delay based on previous paragraph length - much more generous timing
                    const textLength = paragraphText.replace(/<[^>]*>/g, '').length;
                    const readingTime = Math.max(800, Math.min(4000, textLength * 25)); // 25ms per character, min 800ms, max 4000ms
                    const adjustedSpeed = this.animationsDisabled ? 100 : (readingTime / this.speedMultipliers[this.currentSpeedIndex]);
                    
                    // Check for pause markers in the current paragraph and add pause time
                    const pauseTime = this.calculatePauseTime(paragraphText);
                    const totalDelay = adjustedSpeed + pauseTime;
                    
                    setTimeout(() => {
                        this.typeParagraphSequence(paragraphs, index + 1);
                    }, totalDelay);
                }
            }

            revealParagraphWithFade(text) {
                return new Promise((resolve) => {
                    // Create new paragraph element
                    const p = document.createElement('p');
                    const passageText = document.getElementById('passageText');
                    if (!passageText) {
                        resolve();
                        return;
                    }
                    
                    passageText.appendChild(p);
                    
                    // Check if typing is paused
                    if (this.isPaused) {
                        const checkPause = () => {
                            if (this.isPaused) {
                                setTimeout(checkPause, 100);
                            } else {
                                this.performFadeReveal(p, text, resolve);
                            }
                        };
                        checkPause();
                        return;
                    }
                    
                    this.performFadeReveal(p, text, resolve);
                });
            }

            revealParagraphWithGlitch(text) {
                return new Promise((resolve) => {
                    // Create new paragraph element
                    const p = document.createElement('p');
                    const passageText = document.getElementById('passageText');
                    if (!passageText) {
                        resolve();
                        return;
                    }
                    
                    passageText.appendChild(p);
                    
                    // Check if typing is paused
                    if (this.isPaused) {
                        const checkPause = () => {
                            if (this.isPaused) {
                                setTimeout(checkPause, 100);
                            } else {
                                this.performGlitchReveal(p, text, resolve);
                            }
                        };
                        checkPause();
                        return;
                    }
                    
                    this.performGlitchReveal(p, text, resolve);
                });
            }

            performFadeReveal(element, finalText, callback) {
                element.innerHTML = finalText;
                
                // Check if animations are disabled
                if (this.animationsDisabled) {
                    element.style.opacity = '1';
                    element.style.transform = 'translateY(0)';
                    callback();
                    return;
                }
                
                // Very gradual, natural fade-in reveal with character-based timing
                const speedMultiplier = this.speedMultipliers[this.currentSpeedIndex];
                const baseDuration = 1200; // Faster fade-in while keeping long delays
                
                // Adjust duration based on paragraph length
                const textLength = finalText.replace(/<[^>]*>/g, '').length; // Remove HTML tags for character count
                const lengthMultiplier = Math.max(0.5, Math.min(2.0, textLength / 100)); // Scale based on ~100 chars as baseline
                const duration = (baseDuration * lengthMultiplier) / speedMultiplier;
                
                element.style.opacity = '0';
                element.style.transform = 'translateY(3px)'; // Even more minimal movement
                element.style.transition = `opacity ${duration}ms cubic-bezier(0.23, 1, 0.32, 1), transform ${duration}ms cubic-bezier(0.23, 1, 0.32, 1)`; // Very smooth easing
                
                // Trigger the fade-in with a slight delay for naturalness
                setTimeout(() => {
                    element.style.opacity = '1';
                    element.style.transform = 'translateY(0)';
                }, 120); // Slightly longer delay
                
                // Complete after animation
                setTimeout(() => {
                    callback();
                }, duration + 120);
            }

            performGlitchReveal(element, finalText, callback) {
                // Check if animations are disabled
                if (this.animationsDisabled) {
                    element.innerHTML = finalText;
                    element.style.opacity = '1';
                    element.style.textShadow = 'none';
                    callback();
                    return;
                }
                
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?~`';
                const revealDuration = 300; // Total time for reveal
                const glitchPhases = 8; // Number of glitch iterations
                
                let currentPhase = 0;
                
                const glitchStep = () => {
                    if (!this.isTyping) {
                        callback();
                        return;
                    }
                    
                    if (currentPhase >= glitchPhases) {
                        // Final reveal
                        element.innerHTML = finalText;
                        element.style.opacity = '1';
                        element.style.textShadow = 'none';
                        callback();
                        return;
                    }
                    
                    // Create glitched version
                    let glitchedText = '';
                    const revealUpTo = Math.floor((finalText.length * currentPhase) / glitchPhases);
                    
                    for (let i = 0; i < finalText.length; i++) {
                        if (i < revealUpTo) {
                            // Already revealed characters
                            glitchedText += finalText[i];
                        } else if (finalText[i] === ' ') {
                            // Keep spaces
                            glitchedText += ' ';
                        } else if (finalText[i] === '<') {
                            // Handle HTML tags - find closing bracket and keep whole tag
                            const tagEnd = finalText.indexOf('>', i);
                            if (tagEnd !== -1) {
                                glitchedText += finalText.substring(i, tagEnd + 1);
                                i = tagEnd;
                                continue;
                            } else {
                                glitchedText += finalText[i];
                            }
                        } else {
                            // Glitch character
                            glitchedText += glitchChars[Math.floor(Math.random() * glitchChars.length)];
                        }
                    }
                    
                    element.innerHTML = glitchedText;
                    
                    // Add glitch effects
                    const intensity = (glitchPhases - currentPhase) / glitchPhases;
                    element.style.opacity = Math.max(0.7, 1 - intensity * 0.3);
                    element.style.textShadow = `
                        ${Math.random() * 2 - 1}px ${Math.random() * 2 - 1}px 0 #ff3b3b,
                        ${Math.random() * 2 - 1}px ${Math.random() * 2 - 1}px 0 #00ffff
                    `;
                    
                    currentPhase++;
                    setTimeout(glitchStep, revealDuration / glitchPhases);
                };
                
                // Start with completely glitched text
                element.style.opacity = '0.8';
                glitchStep();
            }

            // Calculate total pause time from pause markers in text
            calculatePauseTime(text) {
                if (this.animationsDisabled || this.showAllMode) {
                    return 0; // No pauses in show-all mode or when animations are disabled
                }
                
                // Count pause markers in the text
                const pauseMarkers = text.match(/data-pause=["'](\d+)["']/g);
                if (!pauseMarkers) {
                    return 0;
                }
                
                // Calculate total pause time
                let totalPauseTime = 0;
                pauseMarkers.forEach(marker => {
                    const match = marker.match(/data-pause=["'](\d+)["']/);
                    if (match) {
                        totalPauseTime += parseInt(match[1]);
                    }
                });
                
                // Apply speed multiplier to pause time
                const speedMultiplier = this.speedMultipliers[this.currentSpeedIndex];
                const adjustedPauseTime = totalPauseTime / speedMultiplier;
                
                console.log(`Pause time calculated: ${pauseMarkers.length} markers = ${totalPauseTime}ms (adjusted: ${adjustedPauseTime}ms)`);
                return adjustedPauseTime;
            }

            // Apply crawler fade effect to all visible paragraphs
            applyCrawlerFade() {
                // Skip fade application if in show-all mode
                if (this.showAllMode) return;
                
                const allParagraphs = document.querySelectorAll('.passage-text p');
                const totalParagraphs = allParagraphs.length;
                
                // Only apply fade if we have paragraphs and are in crawler mode
                if (totalParagraphs === 0) return;
                
                allParagraphs.forEach((p, index) => {
                    // Remove all fade classes first
                    p.classList.remove('line-fade-3', 'line-fade-2', 'line-fade-1', 'line-current');
                    
                    // Apply fade based on position from end (most recent)
                    const positionFromEnd = totalParagraphs - 1 - index;
                    
                    if (positionFromEnd === 0) {
                        p.classList.add('line-current'); // Most recent line - fully visible
                    } else if (positionFromEnd === 1) {
                        p.classList.add('line-fade-1'); // 50% visible
                    } else if (positionFromEnd === 2) {
                        p.classList.add('line-fade-2'); // 25% visible  
                    } else if (positionFromEnd >= 3) {
                        p.classList.add('line-fade-3'); // Invisible - prevents overflow into choice area
                    }
                });
            }
            

            
            finishTyping() {
                this.isTyping = false;
                this.updatePauseButton();
                
                // Final fade application only in crawler mode
                if (!this.showAllMode) {
                    this.applyCrawlerFade();
                }
                
                // Show choices - immediately in show-all mode, delayed in crawler mode
                const choicesContainer = document.getElementById('choicesContainer');
                if (choicesContainer) {
                    if (this.showAllMode) {
                        // Immediate in show-all mode
                        choicesContainer.classList.remove('hidden');
                        choicesContainer.classList.add('visible');
                        this.animateChoiceReveal();
                    } else {
                        // Delayed in crawler mode
                        setTimeout(() => {
                            choicesContainer.classList.remove('hidden');
                            choicesContainer.classList.add('visible');
                            this.animateChoiceReveal();
                        }, 400);
                    }
                }
            }
            
            stopTyping() {
                this.isTyping = false;
                if (this.typingInterval) {
                    clearTimeout(this.typingInterval);
                    this.typingInterval = null;
                }
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                this.updatePauseButton();
                
                if (!this.isPaused && this.isTyping) {
                    this.typeNextCharacter();
                }
            }
            
            updatePauseButton() {
                const pauseBtn = document.getElementById('pausePlayBtn');
                if (!pauseBtn) return;
                
                if (this.isTyping && !this.isPaused) {
                    pauseBtn.textContent = '‚è∏';
                    pauseBtn.classList.add('active');
                    pauseBtn.title = 'Pause the typing animation';
                } else {
                    pauseBtn.textContent = '‚ñ∂';
                    pauseBtn.classList.remove('active');
                    if (this.isPaused) {
                        pauseBtn.title = 'Resume the typing animation';
                    } else {
                        pauseBtn.title = 'No typing animation currently running';
                    }
                }
            }

            cycleSpeed() {
                this.currentSpeedIndex = (this.currentSpeedIndex + 1) % this.speedMultipliers.length;
                this.updateRevealSpeed();
                this.updateSpeedButton();
                
                // Save the speed preference immediately
                this.saveProgress();
            }

            updateRevealSpeed() {
                const multiplier = this.speedMultipliers[this.currentSpeedIndex];
                this.revealSpeed = this.animationsDisabled ? 100 : (400 / multiplier); // Faster between paragraphs for longer fades
                console.log(`Reveal speed updated to ${multiplier}x`);
            }

            updateSpeedButton() {
                const speedBtn = document.getElementById('speedBtn');
                if (!speedBtn) return;
                
                const multiplier = this.speedMultipliers[this.currentSpeedIndex];
                speedBtn.textContent = `${multiplier}x`;
                
                // Add active class if not at default speed
                if (multiplier !== 1.0) {
                    speedBtn.classList.add('active');
                } else {
                    speedBtn.classList.remove('active');
                }
            }

            updateShowAllButton() {
                const showAllBtn = document.getElementById('showAllBtn');
                if (!showAllBtn) return;
                
                const storyContainer = document.getElementById('storyContainer');
                const contentArea = document.getElementById('contentArea');
                
                if (this.showAllMode) {
                    showAllBtn.textContent = 'Crawler';
                    showAllBtn.classList.add('active');
                    
                    // Apply show-all CSS classes when loading from saved preference
                    if (storyContainer) {
                        storyContainer.classList.add('show-all');
                    }
                    if (contentArea) {
                        contentArea.classList.add('show-all-content');
                    }
                } else {
                    showAllBtn.textContent = 'Show All';
                    showAllBtn.classList.remove('active');
                    
                    // Remove show-all CSS classes when loading crawler preference
                    if (storyContainer) {
                        storyContainer.classList.remove('show-all');
                    }
                    if (contentArea) {
                        contentArea.classList.remove('show-all-content');
                    }
                }
            }
            
            // Enhanced Save/Load functionality with cross-device sync
            async saveProgress() {
                const saveData = {
                    currentPassageName: this.currentPassage?.name,
                    gameState: this.gameState,
                    passageHistory: this.passageHistory,
                    currentSpeedIndex: this.currentSpeedIndex,
                    showAllMode: this.showAllMode,
                    timestamp: Date.now(),
                    storyId: 'ghost-logic',
                    storyTitle: 'Ghost Logic',
                    progress: this.calculateProgress(),
                    userIP: this.userIP,
                    userId: currentUser?.uid || null
                };
                
                let cloudSaveSuccess = false;
                let localSaveSuccess = false;
                
                try {
                    // ALWAYS save to localStorage (IP-based) regardless of sign-in status
                    const saveKey = `ghost_logic_save_${this.userIP}`;
                    localStorage.setItem(saveKey, JSON.stringify(saveData));
                    localSaveSuccess = true;
                    console.log('‚úÖ Progress saved to localStorage for IP:', this.userIP);
                    
                    // ADDITIONALLY save to Firestore if user is signed in
                    if (currentUser && window.firebase && window.firebase.auth.currentUser) {
                        await window.firebase.setDoc(
                            window.firebase.doc(window.firebase.db, 'users', currentUser.uid),
                            {
                                'saveStates.ghost-logic': saveData,
                                'stats.lastActive': new Date(),
                                'stats.totalPlayTime': (currentUser.stats?.totalPlayTime || 0) + 1,
                                'lastSyncIP': this.userIP // Track which IP last synced
                            },
                            { merge: true }
                        );
                        
                        // Update local storiesPlayed list if not already included
                        if (!currentUser.storiesPlayed.includes('ghost-logic')) {
                            await window.firebase.setDoc(
                                window.firebase.doc(window.firebase.db, 'users', currentUser.uid),
                                {
                                    storiesPlayed: [...currentUser.storiesPlayed, 'ghost-logic']
                                },
                                { merge: true }
                            );
                            currentUser.storiesPlayed.push('ghost-logic');
                        }
                        
                        cloudSaveSuccess = true;
                        console.log('‚úÖ Progress synced to cloud for user:', currentUser.email);
                    }
                    
                    // Log save status
                    if (cloudSaveSuccess && localSaveSuccess) {
                        console.log('üíæ Full sync complete: Local + Cloud saved');
                    } else if (localSaveSuccess) {
                        console.log('üíæ Local save complete (no account)');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error saving progress:', error);
                    
                    // Ensure local save as absolute fallback
                    if (!localSaveSuccess) {
                        try {
                            const saveKey = `ghost_logic_save_${this.userIP}`;
                            localStorage.setItem(saveKey, JSON.stringify(saveData));
                            console.log('üîÑ Emergency local save successful');
                        } catch (localError) {
                            console.error('‚ùå Critical: Both cloud and local saves failed:', localError);
                        }
                    }
                }
            }
            
            async loadProgress() {
                try {
                    console.log('üîÑ Loading progress with cross-device sync...');
                    
                    // Load both local and cloud saves
                    const localSave = await this.loadLocalProgress();
                    const cloudSave = await this.loadCloudProgress();
                    
                    // Determine which save to use and merge if needed
                    const saveData = this.mergeSaveData(localSave, cloudSave);
                    
                    if (saveData) {
                        this.applySaveData(saveData);
                        console.log('‚úÖ Progress loaded successfully');
                    } else {
                        console.log('üìù No previous save found, starting fresh');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error loading progress:', error);
                    
                    // Emergency fallback - try local storage directly
                    try {
                        const saveKey = `ghost_logic_save_${this.userIP}`;
                        const localSaveData = localStorage.getItem(saveKey);
                        if (localSaveData) {
                            const parsed = JSON.parse(localSaveData);
                            this.gameState = parsed.gameState || {};
                            this.passageHistory = parsed.passageHistory || [];
                            console.log('üîÑ Emergency fallback to localStorage successful');
                        }
                    } catch (parseError) {
                        console.error('‚ùå Critical: All save loading methods failed:', parseError);
                    }
                }
            }
            
            async loadLocalProgress() {
                try {
                    const saveKey = `ghost_logic_save_${this.userIP}`;
                    const localSaveData = localStorage.getItem(saveKey);
                    if (localSaveData) {
                        const saveData = JSON.parse(localSaveData);
                        console.log('üì± Local save found for IP:', this.userIP, 'from:', new Date(saveData.timestamp));
                        return saveData;
                    }
                } catch (error) {
                    console.error('‚ùå Error loading local progress:', error);
                }
                return null;
            }
            
            async loadCloudProgress() {
                try {
                    if (currentUser && window.firebase && window.firebase.auth.currentUser) {
                        const userDoc = await window.firebase.getDoc(
                            window.firebase.doc(window.firebase.db, 'users', currentUser.uid)
                        );
                        
                        const userData = userDoc.data();
                        const cloudSave = userData?.saveStates?.['ghost-logic'];
                        
                        if (cloudSave) {
                            console.log('‚òÅÔ∏è Cloud save found for user:', currentUser.email, 'from:', new Date(cloudSave.timestamp));
                            return cloudSave;
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error loading cloud progress:', error);
                }
                return null;
            }
            
            mergeSaveData(localSave, cloudSave) {
                // If only one save exists, use it
                if (localSave && !cloudSave) {
                    console.log('üîÑ Using local save (no cloud save)');
                    return localSave;
                }
                
                if (cloudSave && !localSave) {
                    console.log('üîÑ Using cloud save (no local save)');
                    return cloudSave;
                }
                
                if (!localSave && !cloudSave) {
                    console.log('üìù No saves found');
                    return null;
                }
                
                // Both saves exist - determine which to prioritize
                console.log('üîÄ Both local and cloud saves found, merging...');
                
                const localTimestamp = localSave.timestamp || 0;
                const cloudTimestamp = cloudSave.timestamp || 0;
                const localProgress = localSave.progress || 0;
                const cloudProgress = cloudSave.progress || 0;
                
                // Priority logic:
                // 1. Use the save with more story progress (more passages visited)
                // 2. If progress is equal, use the more recent timestamp
                // 3. Merge preferences from both saves
                
                let primarySave, secondarySave;
                
                if (localProgress > cloudProgress) {
                    console.log(`üìà Local save has more progress (${localProgress}% vs ${cloudProgress}%)`);
                    primarySave = localSave;
                    secondarySave = cloudSave;
                } else if (cloudProgress > localProgress) {
                    console.log(`üìà Cloud save has more progress (${cloudProgress}% vs ${localProgress}%)`);
                    primarySave = cloudSave;
                    secondarySave = localSave;
                } else {
                    // Same progress, use timestamp
                    if (localTimestamp > cloudTimestamp) {
                        console.log('‚è∞ Same progress, local save is more recent');
                        primarySave = localSave;
                        secondarySave = cloudSave;
                    } else {
                        console.log('‚è∞ Same progress, cloud save is more recent');
                        primarySave = cloudSave;
                        secondarySave = localSave;
                    }
                }
                
                // Merge the saves - use primary save as base, merge preferences from secondary
                const mergedSave = {
                    ...primarySave,
                    // Keep user preferences from the more recent save regardless of progress
                    currentSpeedIndex: (localTimestamp > cloudTimestamp ? localSave : cloudSave).currentSpeedIndex,
                    showAllMode: (localTimestamp > cloudTimestamp ? localSave : cloudSave).showAllMode,
                    timestamp: Math.max(localTimestamp, cloudTimestamp)
                };
                
                console.log('‚úÖ Saves merged successfully');
                
                // Note: We don't auto-save here to avoid recursion during loading
                // The merged save will be saved when the user makes progress
                
                return mergedSave;
            }
            
            applySaveData(saveData) {
                this.gameState = saveData.gameState || {};
                this.passageHistory = saveData.passageHistory || [];
                
                // Load reveal speed preference
                if (saveData.currentSpeedIndex !== undefined) {
                    this.currentSpeedIndex = saveData.currentSpeedIndex;
                    this.updateRevealSpeed();
                    console.log('‚ö° Loaded reveal speed:', this.speedMultipliers[this.currentSpeedIndex] + 'x');
                }

                // Load show all mode preference
                if (saveData.showAllMode !== undefined) {
                    this.showAllMode = saveData.showAllMode;
                    this.updateShowAllButton();
                    console.log('üëÅÔ∏è Loaded show all mode:', this.showAllMode);
                }
                
                if (saveData.currentPassageName && this.storyData) {
                    const passage = this.storyData.passages.find(p => p.name === saveData.currentPassageName);
                    if (passage) {
                        this.currentPassage = passage;
                        console.log('üìñ Loaded story position:', saveData.currentPassageName);
                        console.log('üìÖ Save timestamp:', new Date(saveData.timestamp));
                    }
                }
            }
            
            // Calculate progress percentage
            calculateProgress() {
                if (!this.storyData) return 0;
                const totalPassages = this.storyData.passages.length;
                const uniqueVisited = new Set(this.passageHistory).size;
                return totalPassages > 0 ? Math.round((uniqueVisited / totalPassages) * 100) : 0;
            }
            
            confirmRestart() {
                if (confirm('Are you sure you want to start over? Your current progress will be lost.')) {
                    this.restart();
                }
            }
            
            // Review System Methods
            openReviewModal() {
                const modal = document.getElementById('reviewModal');
                modal.style.display = 'flex';
                modal.classList.add('show');
                
                // Reset form state
                this.selectedRating = 0;
                document.querySelectorAll('.star').forEach(star => star.classList.remove('selected'));
                document.getElementById('reviewComment').value = '';
                document.getElementById('submitReview').disabled = true;
                document.getElementById('reviewSuccess').style.display = 'none';
                document.querySelector('.review-modal-content').style.display = 'block';
            }
            
            closeReviewModal() {
                const modal = document.getElementById('reviewModal');
                modal.classList.remove('show');
                setTimeout(() => {
                    modal.style.display = 'none';
                }, 300);
            }
            
            setRating(rating) {
                console.log('Rating set to:', rating);
                this.selectedRating = rating;
                
                // Update star display
                const stars = document.querySelectorAll('#reviewModal .star');
                stars.forEach((star, index) => {
                    if (index < rating) {
                        star.classList.add('selected');
                    } else {
                        star.classList.remove('selected');
                    }
                });
                
                // Enable submit button
                const submitBtn = document.getElementById('submitReview');
                if (submitBtn) {
                    submitBtn.disabled = false;
                }
            }
            
            async submitReview() {
                if (!this.selectedRating) {
                    alert('Please select a rating before submitting.');
                    return;
                }
                
                const submitBtn = document.getElementById('submitReview');
                const originalText = submitBtn.textContent;
                
                try {
                    // Show loading state
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Submitting...';
                    
                    const comment = document.getElementById('reviewComment').value.trim();
                    const currentPassageName = this.currentPassage ? this.currentPassage.name : 'unknown';
                    
                    const reviewData = {
                        rating: this.selectedRating,
                        comment: comment || null,
                        endingName: currentPassageName,
                        userIP: this.userIP,
                        userID: currentUser ? currentUser.uid : null,
                        userEmail: currentUser ? currentUser.email : null,
                        timestamp: new Date(),
                        gameState: Object.keys(this.gameState).length > 0 ? this.gameState : null,
                        passageHistory: this.passageHistory.slice(-5) // Last 5 passages for context
                    };
                    
                    console.log('Submitting review:', reviewData);
                    
                    // Generate a unique review ID
                    const reviewId = `review_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    
                    // Submit to Firebase
                    if (window.firebase && window.firebase.db) {
                        await window.firebase.setDoc(
                            window.firebase.doc(window.firebase.db, 'story_reviews', reviewId),
                            reviewData
                        );
                        console.log('‚úÖ Review submitted to Firebase successfully');
                    } else {
                        console.warn('‚ö†Ô∏è Firebase not available, storing review locally');
                        // Store locally as fallback
                        const localReviews = JSON.parse(localStorage.getItem('ghost_logic_reviews') || '[]');
                        localReviews.push({ id: reviewId, ...reviewData });
                        localStorage.setItem('ghost_logic_reviews', JSON.stringify(localReviews));
                    }
                    
                    // Show success state
                    document.querySelector('.review-modal-content').style.display = 'none';
                    document.getElementById('reviewSuccess').style.display = 'block';
                    
                    // Auto-close modal after 2 seconds
                    setTimeout(() => {
                        this.closeReviewModal();
                    }, 2000);
                    
                    console.log('üéâ Review submitted successfully');
                    
                } catch (error) {
                    console.error('‚ùå Error submitting review:', error);
                    
                    // Try to save locally as fallback
                    try {
                        const comment = document.getElementById('reviewComment').value.trim();
                        const reviewData = {
                            rating: this.selectedRating,
                            comment: comment || null,
                            endingName: this.currentPassage ? this.currentPassage.name : 'unknown',
                            userIP: this.userIP,
                            timestamp: new Date().toISOString(),
                            fallback: true
                        };
                        
                        const localReviews = JSON.parse(localStorage.getItem('ghost_logic_reviews') || '[]');
                        localReviews.push(reviewData);
                        localStorage.setItem('ghost_logic_reviews', JSON.stringify(localReviews));
                        
                        console.log('üíæ Review saved locally as fallback');
                        
                        // Show success state
                        document.querySelector('.review-modal-content').style.display = 'none';
                        document.getElementById('reviewSuccess').style.display = 'block';
                        
                        // Auto-close modal after 2 seconds
                        setTimeout(() => {
                            this.closeReviewModal();
                        }, 2000);
                        
                    } catch (fallbackError) {
                        console.error('‚ùå Fallback save also failed:', fallbackError);
                        alert('There was an error submitting your review. Please try again later.');
                        
                        // Reset button
                        submitBtn.disabled = false;
                        submitBtn.textContent = originalText;
                    }
                }
            }
            
            skipReview() {
                console.log('Review skipped by user');
                this.closeReviewModal();
                
                // Track that review was skipped
                try {
                    const skipData = {
                        action: 'review_skipped',
                        endingName: this.currentPassage ? this.currentPassage.name : 'unknown',
                        userIP: this.userIP,
                        timestamp: new Date(),
                        userID: currentUser ? currentUser.uid : null
                    };
                    
                    if (window.firebase && window.firebase.db) {
                        const skipId = `skip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        window.firebase.setDoc(
                            window.firebase.doc(window.firebase.db, 'story_analytics', skipId),
                            skipData
                        );
                    }
                } catch (error) {
                    console.log('Analytics tracking failed (non-critical):', error);
                }
            }
            
            // Sync progress when user authentication state changes
            async syncOnAuthChange(user) {
                if (!user) {
                    console.log('üë§ User signed out, keeping local progress only');
                    this.showSyncStatus('Local save only (signed out)', 'info');
                    return;
                }
                
                console.log('üîÑ User signed in, syncing progress...', user.email);
                this.showSyncStatus('Syncing progress...', 'loading');
                
                try {
                    // Load both local and cloud saves
                    const localSave = await this.loadLocalProgress();
                    const cloudSave = await this.loadCloudProgress();
                    
                    // If there's local progress but no cloud save, upload local to cloud
                    if (localSave && !cloudSave) {
                        console.log('‚¨ÜÔ∏è Uploading local progress to cloud for first time');
                        await this.saveProgress(); // This will save current state to cloud
                        this.showSyncStatus('Progress uploaded to cloud ‚ú®', 'success');
                        return;
                    }
                    
                    // If both exist, merge and apply
                    if (localSave && cloudSave) {
                        console.log('üîÄ Merging local and cloud progress after sign-in');
                        const mergedSave = this.mergeSaveData(localSave, cloudSave);
                        if (mergedSave && mergedSave !== localSave) {
                            // Only refresh if the merged save is different from current local
                            this.applySaveData(mergedSave);
                            
                            // If we're currently in the middle of a story, refresh the display
                            if (this.currentPassage) {
                                console.log('üîÑ Refreshing story display with synced progress');
                                this.renderPassage();
                                this.updateStateInfo();
                            }
                            this.showSyncStatus('Progress synced across devices ‚ú®', 'success');
                        } else {
                            this.showSyncStatus('Progress already in sync ‚úÖ', 'success');
                        }
                    }
                    
                    // If only cloud save exists, apply it
                    if (!localSave && cloudSave) {
                        console.log('‚¨áÔ∏è Applying cloud progress to this device');
                        this.applySaveData(cloudSave);
                        
                        // Refresh display if we're in a story
                        if (this.currentPassage) {
                            this.renderPassage();
                            this.updateStateInfo();
                        }
                        this.showSyncStatus('Cloud progress restored ‚ú®', 'success');
                    }
                    
                    // If neither save exists, just sync current state
                    if (!localSave && !cloudSave) {
                        this.showSyncStatus('Account connected ‚úÖ', 'success');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error syncing progress on auth change:', error);
                    this.showSyncStatus('Sync error - using local save', 'error');
                }
            }
            
            // Show temporary sync status messages
            showSyncStatus(message, type = 'info') {
                // Create or update sync status element
                let statusEl = document.getElementById('syncStatus');
                if (!statusEl) {
                    statusEl = document.createElement('div');
                    statusEl.id = 'syncStatus';
                    statusEl.style.cssText = `
                        position: fixed;
                        top: 130px;
                        right: 20px;
                        background: rgba(0, 0, 0, 0.9);
                        color: white;
                        padding: 8px 12px;
                        border-radius: 6px;
                        font-family: 'Fira Code', monospace;
                        font-size: 11px;
                        z-index: 10000;
                        opacity: 0;
                        transition: opacity 0.3s ease;
                        pointer-events: none;
                        border: 1px solid rgba(255, 255, 255, 0.1);
                    `;
                    document.body.appendChild(statusEl);
                }
                
                // Style based on type
                const colors = {
                    info: { bg: 'rgba(0, 150, 255, 0.9)', border: 'rgba(0, 150, 255, 0.3)' },
                    success: { bg: 'rgba(0, 200, 100, 0.9)', border: 'rgba(0, 200, 100, 0.3)' },
                    error: { bg: 'rgba(255, 100, 100, 0.9)', border: 'rgba(255, 100, 100, 0.3)' },
                    loading: { bg: 'rgba(255, 150, 0, 0.9)', border: 'rgba(255, 150, 0, 0.3)' }
                };
                
                const color = colors[type] || colors.info;
                statusEl.style.background = color.bg;
                statusEl.style.borderColor = color.border;
                statusEl.textContent = message;
                
                // Show the status
                statusEl.style.opacity = '1';
                
                // Auto-hide after delay (except for loading)
                if (type !== 'loading') {
                    setTimeout(() => {
                        if (statusEl) {
                            statusEl.style.opacity = '0';
                            setTimeout(() => {
                                if (statusEl && statusEl.parentNode) {
                                    statusEl.parentNode.removeChild(statusEl);
                                }
                            }, 300);
                        }
                    }, 3000);
                }
            }

            async restart() {
                try {
                    // Clear save data from both cloud and local storage
                    if (currentUser && window.firebase && window.firebase.auth.currentUser) {
                        await window.firebase.setDoc(
                            window.firebase.doc(window.firebase.db, 'users', currentUser.uid),
                            {
                                'saveStates.ghost-logic': null
                            },
                            { merge: true }
                        );
                        console.log('‚òÅÔ∏è Cloud save cleared for user:', currentUser.email);
                    }
                    
                    // Also clear localStorage
                    const saveKey = `ghost_logic_save_${this.userIP}`;
                    localStorage.removeItem(saveKey);
                    console.log('üíæ Local save cleared for IP:', this.userIP);
                    
                } catch (error) {
                    console.error('‚ùå Error clearing save data:', error);
                    // Still clear localStorage even if cloud clear fails
                    const saveKey = `ghost_logic_save_${this.userIP}`;
                    localStorage.removeItem(saveKey);
                    console.log('üîÑ Local save cleared as fallback');
                }
                
                // Reset all state
                this.currentPassage = null;
                this.gameState = {};
                this.passageHistory = [];
                this.showAllMode = false;
                this.animationsDisabled = false;
                this.stopTyping();
                
                // Reset speed to default
                this.currentSpeedIndex = 1;
                this.updateRevealSpeed();
                this.updateSpeedButton();
                
                // Reset show all button
                const showAllBtn = document.getElementById('showAllBtn');
                if (showAllBtn) {
                    showAllBtn.textContent = 'Show All';
                    showAllBtn.classList.remove('active');
                }
                
                // Restart the story
                this.startStory();
            }

            // Scene Transition Effects
            triggerSceneTransition(callback) {
                const transition = document.getElementById('sceneTransition');
                if (!transition) {
                    callback();
                    return;
                }
                
                // Add glitch effect
                transition.classList.add('glitch', 'active');
                
                setTimeout(() => {
                    callback();
                    setTimeout(() => {
                        transition.classList.remove('glitch', 'active');
                    }, 100);
                }, 300);
            }

            // Choice Animation Methods
            animateChoiceReveal() {
                const choiceButtons = document.querySelectorAll('.choice-button');
                choiceButtons.forEach((button, index) => {
                    setTimeout(() => {
                        button.classList.add('reveal');
                    }, index * 150); // Staggered reveal
                });
            }



            // Choice Feedback
            highlightSelectedChoice(button) {
                // Add selected class for animation
                button.style.background = 'rgba(255, 59, 59, 0.4)';
                button.style.borderColor = '#ff3b3b';
                button.style.transform = 'scale(1.02)';
                button.style.boxShadow = '0 0 20px rgba(255, 59, 59, 0.6)';
                
                // Disable all buttons temporarily
                document.querySelectorAll('.choice-button').forEach(btn => {
                    btn.style.pointerEvents = 'none';
                    if (btn !== button) {
                        btn.style.opacity = '0.5';
                    }
                });
            }





            updateStateInfo() {
                const stateInfo = document.getElementById('stateInfo');
                const currentScene = document.getElementById('currentScene');
                const currentVars = document.getElementById('currentVars');
                
                currentScene.textContent = this.currentPassage.name;
                currentVars.textContent = Object.keys(this.gameState).length;
                
                // Update progress bar
                this.updateProgressBar();
                
                // Update admin panel info if visible
                this.updateAdminInfo();
                
                // Show state info in debug mode
                if (this.currentPassage.tags && this.currentPassage.tags.includes('debug')) {
                    stateInfo.style.display = 'block';
                }
            }

            updateProgressBar() {
                const progressBar = document.getElementById('progressBar');
                if (!progressBar || !this.storyData) return;
                
                // Calculate progress based on passages visited
                const totalPassages = this.storyData.passages.length;
                const uniqueVisited = new Set(this.passageHistory).size;
                const progress = Math.min(100, (uniqueVisited / totalPassages) * 100);
                
                progressBar.style.setProperty('--progress', `${progress}%`);
                
                // Progress bar is always visible now
            }

            // Glitch animation for title
            startGlitchTimer() {
                // Test immediate glitch to verify it works
                setTimeout(() => {
                    this.triggerTitleGlitch();
                }, 1000);
                
                // Trigger glitch every 15 seconds
                this.glitchTimer = setInterval(() => {
                    this.triggerTitleGlitch();
                }, 15000);
                
                // Additional glitch after 5 seconds for good measure
                setTimeout(() => {
                    this.triggerTitleGlitch();
                }, 5000);
            }

            triggerTitleGlitch() {
                const logo = document.querySelector('.glitch-text');
                if (logo) {
                    console.log('Triggering glitch effect on:', logo); // Debug log
                    logo.classList.add('glitch-active');
                    setTimeout(() => {
                        logo.classList.remove('glitch-active');
                        console.log('Glitch effect ended'); // Debug log
                    }, 500);
                } else {
                    console.log('Logo element not found for glitch effect'); // Debug log
                }
            }

            // Show All functionality - reveals entire current scene with scrolling
            toggleShowAll() {
                const showAllBtn = document.getElementById('showAllBtn');
                const storyContainer = document.getElementById('storyContainer');
                const body = document.body;
                
                if (!this.showAllMode) {
                    // Switch to show-all mode: enable scrolling in scene window
                    this.showAllMode = true;
                    this.stopTyping(); // Stop any ongoing animations
                    
                    // Enable show-all styling
                    storyContainer.classList.add('show-all');
                    const contentArea = document.getElementById('contentArea');
                    if (contentArea) {
                        contentArea.classList.add('show-all-content');
                    }
                    
                    // Reveal all text instantly by re-processing the passage text cleanly
                    const passageText = document.getElementById('passageText');
                    if (passageText && this.currentPassage) {
                        // Re-process the text cleanly to avoid any accumulated content
                        const cleanText = this.processText(this.currentPassage.text);
                        passageText.innerHTML = cleanText;
                        
                        // Remove all fade classes and make everything visible instantly
                        const allParagraphs = passageText.querySelectorAll('p');
                        allParagraphs.forEach(p => {
                            p.classList.remove('line-fade-3', 'line-fade-2', 'line-fade-1', 'line-current');
                            p.style.opacity = '1';
                            p.style.transform = 'translateY(0)';
                            p.style.transition = 'none';
                        });
                    }
                    
                    // Show choices immediately
                    const choicesContainer = document.getElementById('choicesContainer');
                    if (choicesContainer) {
                        choicesContainer.classList.remove('hidden');
                        choicesContainer.classList.add('visible');
                        
                        // Make choice buttons visible without animation
                        const choiceButtons = choicesContainer.querySelectorAll('.choice-button');
                        choiceButtons.forEach(button => {
                            button.classList.add('reveal');
                            button.style.transform = 'translateY(0)';
                            button.style.opacity = '1';
                        });
                    }
                    
                    showAllBtn.textContent = 'Crawler';
                    showAllBtn.classList.add('active');
                    
                    // Save preference
                    this.saveProgress();
                } else {
                    // Switch back to crawler mode - reset and restart current scene
                    this.showAllMode = false;
                    
                    showAllBtn.textContent = 'Show All';
                    showAllBtn.classList.remove('active');
                    
                    // Remove show-all styling
                    storyContainer.classList.remove('show-all');
                    const contentArea = document.getElementById('contentArea');
                    if (contentArea) {
                        contentArea.classList.remove('show-all-content');
                    }
                    
                    // Hide choices first
                    const choicesContainer = document.getElementById('choicesContainer');
                    if (choicesContainer) {
                        choicesContainer.classList.add('hidden');
                        choicesContainer.classList.remove('visible');
                    }
                    
                    // Reset typing state
                    this.isTyping = false;
                    this.isPaused = false;
                    this.stopTyping();
                    
                    // Clear existing content and reset all paragraph styles
                    const passageText = document.getElementById('passageText');
                    if (passageText) {
                        // Remove all existing paragraphs and their fade classes
                        const existingParagraphs = passageText.querySelectorAll('p');
                        existingParagraphs.forEach(p => {
                            p.classList.remove('line-fade-3', 'line-fade-2', 'line-fade-1', 'line-current');
                            p.style.opacity = '';
                            p.style.transform = '';
                            p.style.transition = '';
                        });
                    }
                    
                    // Clear content area completely 
                    if (contentArea) {
                        contentArea.innerHTML = '';
                    }
                    
                    // Re-render passage in crawler mode with proper delay
                    setTimeout(() => {
                        this.renderPassage();
                        this.updatePauseButton();
                    }, 100);
                    
                    // Save preference
                    this.saveProgress();
                }
            }

            // Admin Panel Methods
            toggleAdminPanel() {
                const adminPanel = document.getElementById('adminPanel');
                if (!adminPanel) return;
                
                if (adminPanel.style.display === 'none' || !adminPanel.style.display) {
                    adminPanel.style.display = 'block';
                    this.populateSceneDropdown();
                    this.updateAdminGameVars();
                    this.updateAdminInfo();
                } else {
                    adminPanel.style.display = 'none';
                }
            }

            populateSceneDropdown() {
                const sceneSelect = document.getElementById('sceneSelect');
                if (!sceneSelect || !this.storyData) return;
                
                // Clear existing options except the first
                sceneSelect.innerHTML = '<option value="">-- Select Scene --</option>';
                
                // Sort passages by name for easier navigation
                const sortedPassages = [...this.storyData.passages].sort((a, b) => a.name.localeCompare(b.name));
                
                sortedPassages.forEach(passage => {
                    const option = document.createElement('option');
                    option.value = passage.name;
                    option.textContent = passage.name;
                    
                    // Highlight current passage
                    if (this.currentPassage && passage.name === this.currentPassage.name) {
                        option.textContent += ' (current)';
                        option.style.backgroundColor = 'rgba(255, 59, 59, 0.2)';
                    }
                    
                    sceneSelect.appendChild(option);
                });
            }

            refreshSceneList() {
                this.populateSceneDropdown();
            }

            jumpToScene(passageName) {
                if (!passageName || !this.storyData) return;
                
                const passage = this.storyData.passages.find(p => p.name === passageName);
                if (!passage) {
                    alert('Scene not found: ' + passageName);
                    return;
                }
                
                // Confirm scene jump
                if (confirm(`Jump to scene: "${passageName}"?\n\nThis will change your current location in the story.`)) {
                    this.goToPassage(passageName);
                    
                    // Update dropdown to show new current scene
                    setTimeout(() => {
                        this.populateSceneDropdown();
                    }, 100);
                }
            }

            updateAdminGameVars() {
                const gameVarsContainer = document.getElementById('gameVars');
                if (!gameVarsContainer) return;
                
                const vars = Object.keys(this.gameState);
                
                if (vars.length === 0) {
                    gameVarsContainer.innerHTML = '<div class="no-vars">No variables set</div>';
                    return;
                }
                
                const varsHtml = vars.map(varName => {
                    const value = this.gameState[varName];
                    return `
                        <div class="game-var">
                            <span class="var-name">$${varName}</span>
                            <span class="var-value">"${value}"</span>
                            <button class="var-delete" onclick="storyPlayer.deleteGameVariable('${varName}')" title="Delete variable">√ó</button>
                        </div>
                    `;
                }).join('');
                
                gameVarsContainer.innerHTML = varsHtml;
            }

            updateAdminInfo() {
                const adminCurrentScene = document.getElementById('adminCurrentScene');
                const adminSceneId = document.getElementById('adminSceneId');
                const adminSceneTags = document.getElementById('adminSceneTags');
                
                if (!this.currentPassage) return;
                
                if (adminCurrentScene) {
                    adminCurrentScene.textContent = this.currentPassage.name || '-';
                }
                
                if (adminSceneId) {
                    adminSceneId.textContent = this.currentPassage.id || '-';
                }
                
                if (adminSceneTags) {
                    const tags = this.currentPassage.tags;
                    // Ensure tags is an array before calling join
                    if (Array.isArray(tags) && tags.length > 0) {
                        adminSceneTags.textContent = tags.join(', ');
                    } else {
                        adminSceneTags.textContent = 'none';
                    }
                }
            }

            addGameVariable() {
                const varName = prompt('Enter variable name (without $):');
                if (!varName || varName.trim() === '') return;
                
                const cleanVarName = varName.trim().replace(/^\$/, '');
                
                const varValue = prompt(`Enter value for $${cleanVarName}:`);
                if (varValue === null) return; // User cancelled
                
                this.gameState[cleanVarName] = varValue;
                this.updateAdminGameVars();
                this.saveProgress();
                
                console.log(`Admin added variable: $${cleanVarName} = "${varValue}"`);
            }

            deleteGameVariable(varName) {
                if (confirm(`Delete variable $${varName}?`)) {
                    delete this.gameState[varName];
                    this.updateAdminGameVars();
                    this.saveProgress();
                    console.log(`Admin deleted variable: $${varName}`);
                }
            }

            clearGameVariables() {
                if (confirm('Clear all game variables? This cannot be undone.')) {
                    this.gameState = {};
                    this.updateAdminGameVars();
                    this.saveProgress();
                    console.log('Admin cleared all game variables');
                }
            }



        }

        // Initialize the story player
        const storyPlayer = new StoryPlayer();

        // Authentication System (from main index.html)
        let currentUser = null;

        // Initialize authentication on page load
        document.addEventListener('DOMContentLoaded', async function() {
            initializeAuth();
            
            // Don't automatically hide paywall on page load - let story logic handle it
            console.log('üéÆ Story player initialized - paywall will activate when needed');
        });

        function initializeAuth() {
            // Set up Firebase auth listener
            if (window.firebase && window.firebase.onAuthStateChanged) {
                window.firebase.onAuthStateChanged(window.firebase.auth, handleAuthStateChange);
            }
            
            console.log('‚úÖ Story player authentication initialized');
        }

        async function handleAuthStateChange(user) {
            if (user) {
                // User is signed in
                await loadUserProfile(user);
                
                // Don't automatically hide paywall here - let the story logic handle it
                console.log('üîç User signed in - payment status will be checked when reaching paywall');
                const isPaid = await checkUserPaidStatus();
                console.log('üí≥ Payment status:', isPaid ? 'PAID' : 'NOT PAID');
                
                // Sync story progress after user profile is loaded
                if (typeof storyPlayer !== 'undefined' && storyPlayer.syncOnAuthChange) {
                    await storyPlayer.syncOnAuthChange(user);
                }
            } else {
                // User is signed out
                currentUser = null;
                updateUI();
                
                // Notify story player of sign out
                if (typeof storyPlayer !== 'undefined' && storyPlayer.syncOnAuthChange) {
                    await storyPlayer.syncOnAuthChange(null);
                }
            }
        }

        async function loadUserProfile(user) {
            try {
                // Get user profile from Firestore
                const userDoc = await window.firebase.getDoc(
                    window.firebase.doc(window.firebase.db, 'users', user.uid)
                );
                
                const userData = userDoc.data();
                
                currentUser = {
                    uid: user.uid,
                    email: user.email,
                    displayName: userData?.displayName || user.email.split('@')[0],
                    isAdmin: userData?.isAdmin || false,
                    photoURL: user.photoURL,
                    emailVerified: user.emailVerified,
                    // Additional user data from Firestore
                    storiesPlayed: userData?.storiesPlayed || [],
                    storiesOwned: userData?.storiesOwned || [],
                    totalPlayTime: userData?.totalPlayTime || 0,
                    subscription: userData?.subscription || 'free',
                    paid: userData?.paid || false,
                    saveStates: userData?.saveStates || {},
                    preferences: userData?.preferences || {},
                    stats: userData?.stats || {},
                    createdAt: userData?.createdAt || new Date(),
                    lastSignIn: userData?.lastSignIn || new Date()
                };
                
                console.log('üë§ User loaded:', {
                    uid: currentUser.uid,
                    email: currentUser.email,
                    storiesOwned: currentUser.storiesOwned,
                    paid: currentUser.paid
                });
                
                updateUI();
                
            } catch (error) {
                console.error('Error loading user profile:', error);
                // Fallback to basic user info
                currentUser = {
                    uid: user.uid,
                    email: user.email,
                    displayName: user.email.split('@')[0],
                    isAdmin: false
                };
                updateUI();
            }
        }

        function updateUI() {
            const authButtons = document.getElementById('authButtons');
            const userProfile = document.getElementById('userProfile');
            const adminAccessBtn = document.getElementById('adminAccessBtn');
            
            if (currentUser) {
                // User is signed in
                authButtons.style.display = 'none';
                userProfile.style.display = 'flex';
                
                // Update user info
                document.getElementById('userAvatar').textContent = 
                    currentUser.displayName.charAt(0).toUpperCase();
                document.getElementById('userName').textContent = currentUser.displayName;
                document.getElementById('userEmail').textContent = currentUser.email;
                
                // Show admin badge if user is admin
                const adminBadge = document.getElementById('adminBadge');
                adminBadge.style.display = currentUser.isAdmin ? 'block' : 'none';
                
                // Show admin controls if user is admin
                if (adminAccessBtn) {
                    adminAccessBtn.style.display = currentUser.isAdmin ? 'flex' : 'none';
                }
                
            } else {
                // User is signed out
                authButtons.style.display = 'flex';
                userProfile.style.display = 'none';
                if (adminAccessBtn) {
                    adminAccessBtn.style.display = 'none';
                }
            }
        }

        function toggleAuth() {
            if (currentUser) {
                // User is logged in, do nothing (profile info already shown)
                return;
            } else {
                // User not logged in, show auth modal
                showAuthModal();
            }
        }

        async function signOut() {
            console.log('üö™ Sign out button clicked (story player)');
            
            try {
                if (window.firebase && window.firebase.auth.currentUser) {
                    console.log('üì§ Signing out from Firebase...');
                    await window.firebase.signOut(window.firebase.auth);
                    console.log('‚úÖ Successfully signed out from Firebase');
                } else {
                    console.log('‚ö†Ô∏è No Firebase user found, clearing local data only');
                }
                
                currentUser = null;
                updateUI();
                console.log('üîÑ UI updated, user signed out');
                
                // Show sync status
                if (typeof storyPlayer !== 'undefined' && storyPlayer.showSyncStatus) {
                    storyPlayer.showSyncStatus('Signed out - progress saved locally', 'info');
                }
                
            } catch (error) {
                console.error('‚ùå Sign out error:', error);
                // Force sign out even if Firebase fails
                currentUser = null;
                updateUI();
                console.log('üîß Forced local sign out due to error');
                
                // Show error status
                if (typeof storyPlayer !== 'undefined' && storyPlayer.showSyncStatus) {
                    storyPlayer.showSyncStatus('Sign out error - progress saved locally', 'error');
                }
            }
        }

        // Modern Authentication System
        let authMode = 'signin'; // 'signin' or 'signup'
        let isLoading = false;

        function showAuthModal(mode = 'signin') {
            authMode = mode;
            updateAuthModal();
            
            const modal = document.getElementById('authModal');
            modal.style.display = 'flex';
            
            // Trigger animation
            setTimeout(() => {
                modal.classList.add('show');
            }, 10);
            
            // Focus on first input
            setTimeout(() => {
                const firstInput = modal.querySelector('.form-input');
                if (firstInput) firstInput.focus();
            }, 300);
        }

        function closeAuthModal() {
            const modal = document.getElementById('authModal');
            modal.classList.remove('show');
            
            setTimeout(() => {
                modal.style.display = 'none';
                resetAuthForm();
            }, 300);
        }

        function updateAuthModal() {
            const isSignUp = authMode === 'signup';
            
            // Update titles
            document.getElementById('modalTitle').textContent = 
                isSignUp ? 'Create Account' : 'Welcome Back';
            document.getElementById('modalSubtitle').textContent = 
                isSignUp ? 'Join Odysiq and start your adventure' : 'Sign in to continue your adventure';
            
            // Update button text
            document.getElementById('submitText').textContent = 
                isSignUp ? 'Create Account' : 'Sign In';
            
            // Update toggle link
            document.getElementById('authToggleLink').textContent = 
                isSignUp ? 'Already have an account? Sign in' : "Don't have an account? Sign up";
            
            // Clear form
            resetAuthForm();
        }

        function toggleAuthMode() {
            authMode = authMode === 'signin' ? 'signup' : 'signin';
            updateAuthModal();
        }

        function resetAuthForm() {
            document.getElementById('authForm').reset();
            clearMessage();
            setLoading(false);
        }

        function setLoading(loading) {
            isLoading = loading;
            const submitButton = document.getElementById('submitButton');
            const spinner = submitButton.querySelector('.loading-spinner');
            
            submitButton.disabled = loading;
            submitButton.classList.toggle('loading', loading);
            
            if (loading) {
                spinner.style.display = 'inline-block';
            } else {
                spinner.style.display = 'none';
            }
        }

        function showMessage(message, type = 'error') {
            const messageEl = document.getElementById('authMessage');
            messageEl.textContent = message;
            messageEl.className = `message ${type}`;
        }

        function clearMessage() {
            const messageEl = document.getElementById('authMessage');
            messageEl.textContent = '';
            messageEl.className = 'message';
        }

        // Modern Firebase Authentication Functions
        async function handleSignUp(email, password) {
            if (!window.firebase) {
                throw new Error('Firebase not available. Please check your connection.');
            }
            
            try {
                // Create user account
                const userCredential = await window.firebase.createUserWithEmailAndPassword(
                    window.firebase.auth, email, password
                );
                
                const user = userCredential.user;
                const displayName = email.split('@')[0]; // Use email prefix as display name
                
                // Update user profile
                await window.firebase.updateProfile(user, { displayName });
                
                // Create comprehensive user profile in Firestore
                const userProfile = {
                    uid: user.uid,
                    email: email,
                    displayName: displayName,
                    isAdmin: false, // Admin status will be set manually in Firebase console
                    subscription: 'free',
                    storiesPlayed: [],
                    storiesOwned: [], // Stories user has purchased
                    saveStates: {}, // Game save states for different stories
                    preferences: {
                        theme: 'dark',
                        soundEnabled: true,
                        autoSave: true
                    },
                    stats: {
                        totalPlayTime: 0,
                        storiesCompleted: 0,
                        decisionsMode: 0,
                        lastActive: new Date()
                    },
                    createdAt: new Date(),
                    lastSignIn: new Date()
                };
                
                // Save user data to Firestore
                await window.firebase.setDoc(
                    window.firebase.doc(window.firebase.db, 'users', user.uid),
                    userProfile
                );
                
                showMessage('Account created successfully! Welcome to Odysiq! üéâ', 'success');
                
                setTimeout(() => {
                    setLoading(false);
                    closeAuthModal();
                }, 2000);
                
            } catch (error) {
                console.error('Signup error:', error);
                throw error; // Re-throw to be handled by form submission
            }
        }

        async function handleSignIn(email, password) {
            if (!window.firebase) {
                throw new Error('Firebase not available. Please check your connection.');
            }
            
            try {
                await window.firebase.signInWithEmailAndPassword(
                    window.firebase.auth, email, password
                );
                
                // Update last sign in
                const user = window.firebase.auth.currentUser;
                if (user) {
                    await window.firebase.setDoc(
                        window.firebase.doc(window.firebase.db, 'users', user.uid),
                        { 
                            lastSignIn: new Date(),
                            'stats.lastActive': new Date()
                        },
                        { merge: true }
                    );
                }
                
                showMessage('Welcome back! üéÆ', 'success');
                
                setTimeout(() => {
                    setLoading(false);
                    closeAuthModal();
                }, 1500);
                
            } catch (error) {
                console.error('Signin error:', error);
                throw error; // Re-throw to be handled by form submission
            }
        }

        function getErrorMessage(error) {
            switch (error.code) {
                case 'auth/email-already-in-use':
                    return 'An account with this email already exists. Please sign in instead.';
                case 'auth/weak-password':
                    return 'Password is too weak. Please choose a stronger password.';
                case 'auth/invalid-email':
                    return 'Please enter a valid email address.';
                case 'auth/user-not-found':
                    return 'No account found with this email. Please check your email or sign up.';
                case 'auth/wrong-password':
                    return 'Incorrect password. Please try again.';
                case 'auth/too-many-requests':
                    return 'Too many failed attempts. Please try again later.';
                case 'auth/network-request-failed':
                    return 'Network error. Please check your connection and try again.';
                default:
                    return error.message || 'An unexpected error occurred. Please try again.';
            }
        }

        // Form submission handler
        function initializeAuthForm() {
            const authForm = document.getElementById('authForm');
            if (authForm) {
                authForm.addEventListener('submit', async function(e) {
                    e.preventDefault();
                    
                    if (isLoading) return;
                    
                    const email = document.getElementById('email').value.trim();
                    const password = document.getElementById('password').value;
                    
                    // Validation
                    if (!email || !password) {
                        showMessage('Please fill in all required fields');
                        return;
                    }
                    
                    if (password.length < 6) {
                        showMessage('Password must be at least 6 characters long');
                        return;
                    }
                    
                    setLoading(true);
                    clearMessage();
                    
                    try {
                        if (authMode === 'signup') {
                            await handleSignUp(email, password);
                        } else {
                            await handleSignIn(email, password);
                        }
                    } catch (error) {
                        console.error('Auth error:', error);
                        showMessage(getErrorMessage(error));
                        setLoading(false);
                    }
                });
            }
        }

        // Development helpers
        window.clearUserData = function() {
            localStorage.removeItem('currentUser');
            localStorage.removeItem('storyPathsUsers');
            console.log('üßπ Local user data cleared');
            location.reload();
        };

        // Sign out function for UI buttons
        async function handleSignOut() {
            await signOut();
        }
        
        // Emergency sign out helper (if button not working)
        window.forceSignOut = async function() {
            console.log('üÜò Emergency sign out triggered');
            await signOut();
        };

        // Debug helper to manually refresh payment status
        window.refreshPaymentStatus = async function() {
            console.log('üîÑ Manually refreshing payment status...');
            if (currentUser) {
                const isPaid = await checkUserPaidStatus();
                console.log('üí≥ Current payment status:', isPaid);
                
                if (isPaid) {
                    console.log('‚úÖ User has paid - hiding paywall');
                    hidePaywall();
                    
                    // Try to continue story
                    if (typeof storyPlayer !== 'undefined' && storyPlayer.currentPassage) {
                        console.log('üé¨ Continuing story...');
                        storyPlayer.renderPassage();
                    }
                } else {
                    console.log('‚ùå User has not paid - paywall remains');
                }
            } else {
                console.log('‚ùå No user logged in');
            }
        };

        // Debug helper to test Firebase connectivity
        window.testFirebaseConnection = async function() {
            console.log('üß™ Testing Firebase connection...');
            
            if (!currentUser) {
                console.log('‚ùå No authenticated user - please sign in first');
                return;
            }
            
            try {
                console.log('üîç Testing Firestore read access...');
                const userDocRef = window.firebase.doc(window.firebase.db, 'users', currentUser.uid);
                const userDoc = await window.firebase.getDoc(userDocRef);
                
                if (userDoc.exists()) {
                    console.log('‚úÖ Firestore read successful!');
                    console.log('üìÑ User document data:', userDoc.data());
                } else {
                    console.log('‚ö†Ô∏è User document does not exist');
                }
                
                console.log('üîç Testing Firestore write access...');
                await window.firebase.setDoc(userDocRef, {
                    lastConnectivityTest: new Date(),
                    testStatus: 'success'
                }, { merge: true });
                
                console.log('‚úÖ Firestore write successful!');
                console.log('üéâ Firebase connection is working properly');
                
            } catch (error) {
                console.error('‚ùå Firebase connectivity test failed:', error);
                window.firebaseErrorHandler('testFirebaseConnection', error);
                
                if (error.code === 'permission-denied') {
                    console.log('üîß SOLUTION: Update your Firestore security rules');
                    console.log('üìù Go to Firebase Console > Firestore > Rules');
                    console.log('üîó https://console.firebase.google.com/project/odysiq-90653/firestore/rules');
                } else if (error.code === 'unauthenticated') {
                    console.log('üîß SOLUTION: Make sure you are signed in');
                }
            }
        };

        // Debug helper to test paywall logic
        window.testPaywallLogic = async function() {
            console.log('üß™ Testing Paywall Logic...');
            
            if (!currentUser) {
                console.log('‚ùå No user signed in - sign in first to test');
                return;
            }
            
            console.log('üë§ Current User:', {
                uid: currentUser.uid,
                email: currentUser.email,
                storiesOwned: currentUser.storiesOwned
            });
            
            const isPaid = await checkUserPaidStatus();
            console.log('üí≥ Payment Status:', isPaid ? '‚úÖ PAID' : '‚ùå NOT PAID');
            
            const paywallResult = await checkPaywallRequired('Scene 13');
            console.log('üö™ Paywall Result for Scene 13:', paywallResult ? 'üö´ BLOCKED' : '‚úÖ ALLOWED');
            
            console.log('üéØ Expected behavior:');
            console.log('  - If storiesOwned contains "ghost-logic": Should be PAID and ALLOWED');
            console.log('  - If storiesOwned is empty: Should be NOT PAID and BLOCKED');
        };

        // Debug helper to manually add Ghost Logic to owned stories
        window.grantGhostLogicAccess = async function() {
            console.log('üéÅ Manually granting Ghost Logic access...');
            if (!currentUser) {
                console.log('‚ùå No user logged in');
                return;
            }
            
            try {
                // Get current user data
                const userDoc = await window.firebase.getDoc(
                    window.firebase.doc(window.firebase.db, 'users', currentUser.uid)
                );
                
                const userData = userDoc.exists() ? userDoc.data() : {};
                const currentStoriesOwned = userData.storiesOwned || [];
                
                // Check if user already owns any variation of Ghost Logic
                const ghostLogicVariations = ['ghost-logic', 'Ghost-Logic', 'Ghost Logic', 'ghost logic'];
                const alreadyOwns = currentStoriesOwned.some(story => 
                    ghostLogicVariations.some(variation => 
                        story.toLowerCase() === variation.toLowerCase()
                    )
                );
                
                if (alreadyOwns) {
                    console.log('‚úÖ User already owns Ghost Logic');
                    return;
                }
                
                // Add ghost-logic to owned stories (using consistent lowercase format)
                const updatedStoriesOwned = [...currentStoriesOwned, 'ghost-logic'];
                
                await window.firebase.setDoc(
                    window.firebase.doc(window.firebase.db, 'users', currentUser.uid),
                    { 
                        storiesOwned: updatedStoriesOwned
                        // Note: Only storiesOwned matters for access control
                    },
                    { merge: true }
                );
                
                console.log('‚úÖ Ghost Logic access granted!');
                console.log('üìö User now owns:', updatedStoriesOwned);
                
                // Update local user object
                if (currentUser) {
                    currentUser.storiesOwned = updatedStoriesOwned;
                }
                
                // Refresh and hide paywall
                await window.refreshPaymentStatus();
                
            } catch (error) {
                console.error('‚ùå Error granting access:', error);
            }
        };

        // Complete initialization
        setTimeout(() => {
            initializeAuthForm();
            
            // Close modal on outside click
            const authModal = document.getElementById('authModal');
            if (authModal) {
                authModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeAuthModal();
                    }
                });
            }
            
            // Review modal event listeners
            const reviewModal = document.getElementById('reviewModal');
            if (reviewModal) {
                reviewModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        storyPlayer.closeReviewModal();
                    }
                });
            }
            
            // Close modal on ESC key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    const authModalEl = document.getElementById('authModal');
                    const reviewModalEl = document.getElementById('reviewModal');
                    
                    if (authModalEl && authModalEl.style.display === 'flex') {
                        closeAuthModal();
                    } else if (reviewModalEl && reviewModalEl.style.display === 'flex') {
                        storyPlayer.closeReviewModal();
                    }
                }
                
                // Emergency sign out shortcut (Ctrl+Shift+L)
                if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                    console.log('‚å®Ô∏è Emergency sign out shortcut triggered (Ctrl+Shift+L)');
                    signOut();
                }
            });
            
            console.log('üí° Debug commands: window.clearUserData(), window.forceSignOut(), window.refreshPaymentStatus(), window.grantGhostLogicAccess(), window.testFirebaseConnection(), window.testPaywallLogic()');
            
        }, 1000); // Give Firebase time to load
    </script>

    <!-- Paywall Overlay -->
    <div id="paywallOverlay" class="paywall-overlay">
        <div class="paywall-container">
            <button class="paywall-close" onclick="hidePaywall()">&times;</button>
            <h1 class="paywall-title">Unlock Ash's Mystery</h1>
            <p class="paywall-subtitle">The conspiracy deepens. The truth awaits in the shadows of the city.</p>
            
            <div class="paywall-features">
                <h3>Continue the Adventure</h3>
                <ul>
                    <li>Uncover the dark secrets of Project Helix</li>
                    <li>Navigate the cyber-noir underworld of Arcadia</li>
                    <li>Experience multiple branching storylines</li>
                    <li>Discover the truth behind Ash's brother's death</li>
                    <li>Face off against corporate conspiracies</li>
                </ul>
            </div>
            
            <div id="authPrompt" class="auth-prompt" style="display: none;">
                <h3>Account Required</h3>
                <p>Please sign up or log in to continue your journey through Ghost Logic.</p>
                <div class="paywall-buttons">
                    <button class="paywall-btn secondary" onclick="showAuthModal('signup')">Sign Up</button>
                    <button class="paywall-btn secondary" onclick="showAuthModal('login')">Log In</button>
                </div>
            </div>
            
                         <div id="paymentPrompt" class="paywall-buttons">
                 <button class="paywall-btn primary" onclick="initiatePayment()">
                     <span id="paymentButtonText">Unlock Full Story - $2.99</span>
                 </button>
                 
                 <div class="promo-section">
                     <div class="promo-toggle" onclick="togglePromoCode()">
                         <span id="promoToggleText">üìã Have a promo code?</span>
                     </div>
                     <div id="promoCodeInput" class="promo-input-container" style="display: none;">
                         <input type="text" id="promoCodeField" placeholder="Enter promo code" class="promo-input">
                         <button class="paywall-btn promo" onclick="applyPromoCode()">Apply Code</button>
                     </div>
                     <div id="promoResult" class="promo-result" style="display: none;"></div>
                 </div>
             </div>
        </div>
    </div>

    <script>
        // Initialize Stripe - Replace with your actual Stripe publishable key
        stripe = Stripe(window.STRIPE_PUBLISHABLE_KEY || 'pk_live_YOUR_STRIPE_PUBLISHABLE_KEY_HERE');
        
        // Paywall System - simplified to only use storiesOwned array

        // Check server status
        async function checkServerStatus() {
            try {
                const response = await fetch(`${window.API_BASE_URL}/api/health`);
                if (response.ok) {
                    console.log('‚úÖ Server is running');
                    return true;
                } else {
                    console.warn('‚ö†Ô∏è Server responded but with error status:', response.status);
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Server is not running:', error.message);
                return false;
            }
        }

        // Check if user owns the Ghost Logic story
        async function checkUserPaidStatus() {
            if (!currentUser) {
                console.log('‚ùå No current user - cannot check payment status');
                return false;
            }
            
            // Removed localhost bypass - paywall should work normally based on storiesOwned array
            
            try {
                console.log('üîç Checking payment status for user:', currentUser.uid);
                console.log('üîë User auth state:', {
                    uid: currentUser.uid,
                    email: currentUser.email,
                    emailVerified: currentUser.emailVerified
                });
                
                const userDoc = await window.firebase.getDoc(
                    window.firebase.doc(window.firebase.db, 'users', currentUser.uid)
                );
                
                if (!userDoc.exists()) {
                    console.log('‚ùå User document does not exist in Firebase');
                    console.log('üí° This might be a new user or a Firestore access issue');
                    return false;
                }
                
                const userData = userDoc.data();
                const storiesOwned = userData?.storiesOwned || [];
                
                // Check for Ghost Logic with case-insensitive matching
                const ghostLogicVariations = ['ghost-logic', 'Ghost-Logic', 'Ghost Logic', 'ghost logic'];
                const ownsGhostLogic = storiesOwned.some(story => 
                    ghostLogicVariations.some(variation => 
                        story.toLowerCase() === variation.toLowerCase()
                    )
                );
                
                console.log('üìä User payment data:', {
                    uid: currentUser.uid,
                    email: currentUser.email,
                    storiesOwned: storiesOwned,
                    ownsGhostLogic: ownsGhostLogic,
                    // Also log legacy fields for debugging
                    paid: userData?.paid,
                    subscription: userData?.subscription
                });
                
                // Primary check: Does user own Ghost Logic story (any variation)?
                if (ownsGhostLogic) {
                    console.log('‚úÖ User owns Ghost Logic story');
                    return true;
                } else {
                    console.log('‚ùå User does not own Ghost Logic story');
                    console.log('üîç Looking for any of:', ghostLogicVariations);
                    console.log('üìö User currently owns:', storiesOwned);
                    return false;
                }
                
            } catch (error) {
                // Use enhanced error handler
                window.firebaseErrorHandler('checkUserPaidStatus', error);
                
                console.log('üîÑ Falling back to local user data check...');
                
                // Fallback: check local currentUser object
                if (currentUser && currentUser.storiesOwned) {
                    const localStoriesOwned = currentUser.storiesOwned || [];
                    const ghostLogicVariations = ['ghost-logic', 'Ghost-Logic', 'Ghost Logic', 'ghost logic'];
                    const ownsGhostLogic = localStoriesOwned.some(story => 
                        ghostLogicVariations.some(variation => 
                            story.toLowerCase() === variation.toLowerCase()
                        )
                    );
                    
                    console.log('üè† Local user data check:', {
                        storiesOwned: localStoriesOwned,
                        ownsGhostLogic: ownsGhostLogic
                    });
                    
                    return ownsGhostLogic;
                }
                
                // No admin override during testing - pure payment logic only
                
                return false;
            }
        }

        // Show paywall only on Scene 13 specifically
        async function checkPaywallRequired(sceneName) {
            // Check if this is exactly Scene 13 (not later scenes)
            const sceneNumber = extractSceneNumber(sceneName);
            if (sceneNumber === 13) {
                const isPaid = await checkUserPaidStatus();
                if (!isPaid) {
                    showPaywall();
                    return true; // Block scene rendering
                }
            }
            return false; // Allow scene rendering
        }

        // Extract scene number from scene name
        function extractSceneNumber(sceneName) {
            const match = sceneName.match(/Scene (\d+)/i);
            return match ? parseInt(match[1]) : 0;
        }

        // Show the paywall
        function showPaywall() {
            const paywallOverlay = document.getElementById('paywallOverlay');
            const authPrompt = document.getElementById('authPrompt');
            const paymentPrompt = document.getElementById('paymentPrompt');
            
            if (currentUser) {
                // User is logged in, show payment prompt
                authPrompt.style.display = 'none';
                paymentPrompt.style.display = 'block';
            } else {
                // User not logged in, show auth prompt
                authPrompt.style.display = 'block';
                paymentPrompt.style.display = 'none';
            }
            
            paywallOverlay.classList.add('active');
        }

        // Hide the paywall
        function hidePaywall() {
            const paywallOverlay = document.getElementById('paywallOverlay');
            paywallOverlay.classList.remove('active');
        }

                 // Initiate Stripe payment
         async function initiatePayment(promoCode = null) {
             if (!currentUser) {
                 showAuthModal('signup');
                 return;
             }

             const paymentButton = document.getElementById('paymentButtonText');
             const originalText = paymentButton.textContent;
             
             try {
                 paymentButton.innerHTML = '<span class="loading-spinner"></span>Checking server...';
                 
                 // Check if server is running first
                 const serverRunning = await checkServerStatus();
                 if (!serverRunning) {
                     throw new Error('Server is not running. Please start the server with "npm start" and try again.');
                 }
                 
                 paymentButton.innerHTML = '<span class="loading-spinner"></span>Processing...';
                 
                 const requestBody = {
                     userId: currentUser.uid,
                     userEmail: currentUser.email,
                     priceId: 'price_ghost_logic_full_story', // This would be your Stripe price ID
                     successUrl: window.location.href + '?payment=success',
                     cancelUrl: window.location.href + '?payment=cancelled'
                 };

                 // Add promo code if provided
                 if (promoCode) {
                     requestBody.promoCode = promoCode;
                 }
                 
                 // Create checkout session
                 const response = await fetch(`${window.API_BASE_URL}/api/create-checkout-session`, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify(requestBody)
                 });

                 if (!response.ok) {
                     const errorData = await response.json();
                     throw new Error(errorData.error || 'Failed to create checkout session');
                 }

                 const session = await response.json();
                 
                 // Redirect to Stripe Checkout
                 const result = await stripe.redirectToCheckout({
                     sessionId: session.id
                 });

                 if (result.error) {
                     throw new Error(result.error.message);
                 }
                 
             } catch (error) {
                 console.error('Payment error:', error);
                 paymentButton.textContent = originalText;
                 
                 // More detailed error handling
                 let errorMessage = 'Payment failed. Please try again or contact support.';
                 
                 if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                     errorMessage = 'Server connection failed. Please make sure the server is running and try again.';
                 } else if (error.message.includes('404')) {
                     errorMessage = 'Payment service not found. Server may not be running.';
                 } else if (error.message.includes('500')) {
                     errorMessage = 'Server error occurred. Please check server logs and try again.';
                 } else if (promoCode && error.message.includes('coupon')) {
                     showPromoResult(error.message, 'error');
                     return; // Don't show alert for promo code errors
                 }
                 
                 alert(errorMessage + '\n\nTechnical details: ' + error.message);
             }
         }

         // Toggle promo code input
         function togglePromoCode() {
             const promoInput = document.getElementById('promoCodeInput');
             const toggleText = document.getElementById('promoToggleText');
             
             if (promoInput.style.display === 'none') {
                 promoInput.style.display = 'flex';
                 toggleText.textContent = '‚ùå Cancel promo code';
                 document.getElementById('promoCodeField').focus();
             } else {
                 promoInput.style.display = 'none';
                 toggleText.textContent = 'üìã Have a promo code?';
                 hidePromoResult();
             }
         }

         // Apply promo code
         async function applyPromoCode() {
             const promoField = document.getElementById('promoCodeField');
             const promoCode = promoField.value.trim().toUpperCase();
             
             if (!promoCode) {
                 showPromoResult('Please enter a promo code', 'error');
                 return;
             }

             if (!currentUser) {
                 showAuthModal('signup');
                 return;
             }

             try {
                 showPromoResult('Validating promo code...', 'info');
                 
                 // Validate promo code with Stripe
                 const response = await fetch(`${window.API_BASE_URL}/api/validate-promo-code`, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify({
                         promoCode: promoCode,
                         userId: currentUser.uid
                     })
                 });

                 const result = await response.json();
                 
                 if (response.ok && result.valid) {
                     showPromoResult(`‚úÖ Promo code applied! ${result.discount}`, 'success');
                     // Update payment button text
                     const paymentButton = document.getElementById('paymentButtonText');
                     paymentButton.textContent = `Unlock Full Story - ${result.finalPrice}`;
                     
                     // Proceed with payment immediately to maintain user interaction context
                     // This prevents popup blockers from interfering with Stripe redirect
                     await initiatePayment(promoCode);
                     
                 } else {
                     showPromoResult(result.error || 'Invalid promo code', 'error');
                 }
                 
             } catch (error) {
                 console.error('Promo code validation error:', error);
                 showPromoResult('Error validating promo code. Please try again.', 'error');
             }
         }

         // Show promo result message
         function showPromoResult(message, type) {
             const promoResult = document.getElementById('promoResult');
             promoResult.textContent = message;
             promoResult.className = `promo-result ${type}`;
             promoResult.style.display = 'block';
         }

         // Hide promo result message
         function hidePromoResult() {
             const promoResult = document.getElementById('promoResult');
             promoResult.style.display = 'none';
         }

         // Handle Enter key in promo code input
         document.addEventListener('DOMContentLoaded', function() {
             const promoField = document.getElementById('promoCodeField');
             if (promoField) {
                 promoField.addEventListener('keypress', function(e) {
                     if (e.key === 'Enter') {
                         applyPromoCode();
                     }
                 });
             }
         });

        // Handle payment success
        async function handlePaymentSuccess() {
            try {
                console.log('üéâ Processing payment success for user:', currentUser.uid);
                
                // Get current user data
                const userDoc = await window.firebase.getDoc(
                    window.firebase.doc(window.firebase.db, 'users', currentUser.uid)
                );
                
                let userData = {};
                if (userDoc.exists()) {
                    userData = userDoc.data();
                } else {
                    console.log('‚ö†Ô∏è User document does not exist, will create it');
                }
                
                const currentStoriesOwned = userData.storiesOwned || [];
                
                // Check if user already owns the story
                if (currentStoriesOwned.includes('ghost-logic')) {
                    console.log('‚úÖ User already owns Ghost Logic story');
                } else {
                    console.log('üìù Adding Ghost Logic to user\'s owned stories');
                }
                
                // Update storiesOwned array - primary field for access control
                const updatedStoriesOwned = currentStoriesOwned.includes('ghost-logic') 
                    ? currentStoriesOwned 
                    : [...currentStoriesOwned, 'ghost-logic'];
                
                const updateData = { 
                    storiesOwned: updatedStoriesOwned,
                    // Also update these for completeness/legacy support
                    paid: true,
                    paidAt: new Date(),
                    subscription: 'premium',
                    lastPaymentDate: new Date()
                };
                
                console.log('üíæ Updating Firebase with:', updateData);
                
                await window.firebase.setDoc(
                    window.firebase.doc(window.firebase.db, 'users', currentUser.uid),
                    updateData,
                    { merge: true }
                );
                
                console.log('‚úÖ Firebase updated successfully');
                
                // Update local user object
                if (currentUser) {
                    currentUser.storiesOwned = updatedStoriesOwned;
                    currentUser.paid = true;
                    currentUser.subscription = 'premium';
                }
                
                // Refresh payment status to verify the update worked
                userPaidStatus = await checkUserPaidStatus();
                console.log('üîÑ Refreshed payment status:', userPaidStatus);
                
                if (userPaidStatus) {
                    hidePaywall();
                    
                    // Show success message
                    if (typeof storyPlayer !== 'undefined' && storyPlayer.showSyncStatus) {
                        storyPlayer.showSyncStatus('Payment successful! Ghost Logic story unlocked ‚ú®', 'success');
                    }
                    
                    // Continue with the story
                    setTimeout(() => {
                        if (typeof storyPlayer !== 'undefined' && storyPlayer.currentPassage) {
                            console.log('üé¨ Continuing story after payment...');
                            storyPlayer.renderPassage();
                        } else {
                            console.log('üîÑ Refreshing page to continue story...');
                            window.location.reload();
                        }
                    }, 1000);
                } else {
                    console.error('‚ùå Payment status check failed after update');
                    alert('Payment was successful, but there was an issue verifying your access. Please refresh the page or contact support.');
                }
                
            } catch (error) {
                window.firebaseErrorHandler('handlePaymentSuccess', error);
                
                // Try to save locally as fallback
                try {
                    if (currentUser) {
                        const existingOwned = currentUser.storiesOwned || [];
                        if (!existingOwned.some(story => story.toLowerCase().includes('ghost'))) {
                            currentUser.storiesOwned = [...existingOwned, 'ghost-logic'];
                            currentUser.paid = true;
                            currentUser.subscription = 'premium';
                            
                            console.log('üíæ Updated local user data as fallback');
                            userPaidStatus = true;
                            hidePaywall();
                            
                            alert('Payment successful! Your access has been granted locally. The system will try to sync with the server later.');
                            return;
                        }
                    }
                } catch (fallbackError) {
                    console.error('‚ùå Fallback save also failed:', fallbackError);
                }
                
                alert('Payment was successful, but there was an error updating your account. Please refresh the page or contact support.\n\nError: ' + error.message);
            }
        }

        // Check for payment success on page load
        let paymentSuccessDetected = false;
        
        function checkForPaymentSuccess() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('payment') === 'success' && !paymentSuccessDetected) {
                console.log('üí≥ Payment success detected in URL');
                paymentSuccessDetected = true;
                
                // Clear the URL parameter
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Handle payment success - wait for user if needed
                if (currentUser) {
                    console.log('üë§ User already loaded, processing payment success');
                    handlePaymentSuccess();
                } else {
                    console.log('‚è≥ Waiting for user authentication to complete...');
                    // Wait for authentication to complete
                    const checkUserInterval = setInterval(() => {
                        if (currentUser) {
                            console.log('üë§ User loaded, processing payment success');
                            clearInterval(checkUserInterval);
                            handlePaymentSuccess();
                        }
                    }, 100); // Check every 100ms
                    
                    // Timeout after 10 seconds
                    setTimeout(() => {
                        clearInterval(checkUserInterval);
                        if (!currentUser) {
                            console.error('‚ùå Timeout waiting for user authentication');
                            alert('Payment was successful, but there was an issue loading your account. Please refresh the page.');
                        }
                    }, 10000);
                }
            }
        }
        
        // Check on page load
        window.addEventListener('load', checkForPaymentSuccess);
        
        // Also check when DOM is ready (earlier than load)
        document.addEventListener('DOMContentLoaded', checkForPaymentSuccess);

        // Override auth state change to update paywall status
        const originalHandleAuthStateChange = handleAuthStateChange;
        handleAuthStateChange = async function(user) {
            await originalHandleAuthStateChange(user);
            
            if (user) {
                userPaidStatus = await checkUserPaidStatus();
                
                            // Check for pending payment success after user loads
            if (paymentSuccessDetected && currentUser) {
                console.log('üîÑ User loaded after payment success - processing now');
                handlePaymentSuccess();
            }
                
                // If paywall is showing and user is now logged in, update the display
                const paywallOverlay = document.getElementById('paywallOverlay');
                if (paywallOverlay.classList.contains('active')) {
                    if (userPaidStatus) {
                        // User has paid, hide paywall and continue story
                        console.log('‚úÖ Paid user detected on page load - hiding paywall');
                        hidePaywall();
                    } else {
                        // User hasn't paid, refresh paywall display for correct user state
                        showPaywall();
                    }
                }
                
                // If there's a current story scene loaded, re-render to check paywall status
                // Only re-render if we're on Scene 13 or haven't paid yet
                if (typeof storyPlayer !== 'undefined' && storyPlayer.currentPassage) {
                    const currentSceneNumber = extractSceneNumber(storyPlayer.currentPassage.name);
                    if (currentSceneNumber === 13 || !userPaidStatus) {
                        console.log('üîÑ Re-rendering scene after auth restore to check payment status');
                        storyPlayer.renderPassage();
                    } else {
                        console.log('üìñ Scene past paywall checkpoint - no re-render needed');
                    }
                }
            } else {
                userPaidStatus = false;
            }
        };
    </script>
</body>
</html> 